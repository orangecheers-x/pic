{"meta":{"title":"Orange Cheers!","subtitle":"","description":"","author":"Orange Cheers","url":"https://orangecheers.top","root":"/"},"pages":[{"title":"所有分类","date":"2022-03-21T09:20:13.104Z","updated":"2021-10-14T12:54:01.000Z","comments":true,"path":"categories/index.html","permalink":"https://orangecheers.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-21T14:13:32.878Z","updated":"2021-07-08T14:18:19.000Z","comments":true,"path":"friends/index.html","permalink":"https://orangecheers.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-21T10:39:12.212Z","updated":"2022-03-21T10:38:56.305Z","comments":true,"path":"about/index.html","permalink":"https://orangecheers.top/about/index.html","excerpt":"","text":"西电计科大三, 曾经oi人, 半退役acm人. Loveliver/邦邦人, 主推穂乃果和ksm. 脱单啦, 我女朋友 @ClaireEleanor99 最可爱啦."},{"title":"","date":"2022-03-21T10:28:01.858Z","updated":"2021-10-14T12:51:16.000Z","comments":true,"path":"about/index-secret.html","permalink":"https://orangecheers.top/about/index-secret.html","excerpt":"","text":"我是Orange Cheers, 现在在西安电子科技大学计算机科学与技术专业读大三. 四年级开始接触编程, 当时学的是C#. 初中主要在研究Android开发, 高中打过NOIP, 大学打过ACM和数模, 现在对机器学习系统 (Systems for ML) 有点感兴趣. Loveliver/邦邦人, 主推穂乃果和ksm. 脱单啦, 我女朋友 @ClaireEleanor99 最可爱啦. 获奖 2016.12 全国信息学奥林匹克联赛(NOIP 2016)提高组 省级三等奖 2017.10 中国化学奥林匹克 省级二等奖 2018.12 全国信息学奥林匹克联赛(NOIP 2016)提高组 省级二等奖 2019.12 西安电子科技大学ACM程序设计新生赛 一等奖 2019.12 西安电子科技大学微软俱乐部 优秀部员 2019.12 全国计算机软件能力认证(CSP) 全国前2% 2020.09 西安电子科技大学ACM程序设计校赛 一等奖 2020.09 陕西省大学生程序设计竞赛 铜奖 2020.10 西安电子科技大学校级一等奖学金 2020.10 CCF大学生计算机系统与程序设计竞赛 (CCSP)西北赛区银奖、全国铜奖 2020.10 IEEEXtreme 14.0 极限编程竞赛全球排名 53/3701 2020.11 CCCC团体程序设计天梯赛全国个人银奖、团队铜奖 2020.12 第十二届全国大学生数学竞赛陕西省二等奖 2020.12 第45届国际大学生程序设计竞赛 (ICPC) 亚洲区域赛 (济南) 铜奖 2020.04 美国大学生数学建模竞赛（MCM/ICM）国际一等奖 (Meritorious Winner) 2021.04 西安电子科技大学 优秀学生 2021.05 CCCC团体程序设计天梯赛全国个人银奖、团队铜奖 2021.06 第45届国际大学生程序设计竞赛 (ICPC) 全国邀请赛(西安) 银奖 2021.09 中国计算机学会 CCF优秀大学生奖 2021.10 国家奖学金 经历 2020.06 西安电子科技大学 ACM竞赛双创周 讲师 2020.06 - 现在 西安电子科技大学微软俱乐部 ACM组Mentor 2020.08 转专业, 软件工程--&gt;计算机科学与技术, 排名 9/328 2020.10 综合测评 11/324 &amp; 校级一等奖学金 2021.06-现在 西安电子科技大学微软俱乐部 副主席 2021.07 陕西师范大学附属中学 信息学竞赛讲师 2021.08 计算机科学与技术专业 网络与信息安全方向 2021.10 综合测评 3/484 &amp; 国家奖学金"},{"title":"所有标签","date":"2022-03-21T09:20:12.894Z","updated":"2021-07-08T14:19:58.000Z","comments":true,"path":"tags/index.html","permalink":"https://orangecheers.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"并发中的同步","slug":"sync","date":"2022-08-26T16:19:38.000Z","updated":"2022-08-26T16:23:55.354Z","comments":true,"path":"2022/08/27/sync/","link":"","permalink":"https://orangecheers.top/2022/08/27/sync/","excerpt":"条件变量, 哲学家吃饭 条件变量 条件变量用在一个线程需要一直等待一个条件满足后在执行. 比如下面这段代码就是等待count==n满足之后再继续执行. 即使用上了互斥锁, 不用自旋锁, 也是有个类似自旋的过程的:","text":"条件变量, 哲学家吃饭 条件变量 条件变量用在一个线程需要一直等待一个条件满足后在执行. 比如下面这段代码就是等待count==n满足之后再继续执行. 即使用上了互斥锁, 不用自旋锁, 也是有个类似自旋的过程的: retry: mutex_lock(&amp;lk); if (count == n) &#123; mutex_unlock(&amp;lk); goto retry; &#125; 只不过, 这个自旋没有自旋锁那么暴力, 他是更大层面上的自旋: 自旋锁是在上锁的时候, 也就是mutex_lock的时候去自旋, 尝试上锁, 无法上锁就继续自旋. 这个自旋是上锁之后判断条件是否满足, 如果没有条件不能满足就解锁. 这个自旋是有条件的, 注意因为mutex他是维护了一个waiter序列, lock失败后这个线程会阻塞, 只有当有人unlock了之后, 这个线程被唤醒了, 才会去尝试这个大自旋. 看起来, 这个锁尝试自旋的次数并不是很多, 因为只有有人unlock之后他才会自旋. 但是, 一个mutex可能管理了很多个变量, 这个锁可能会非常大, 很有可能一个线程lock了之后更改了一些毫不相干的变量, 然后unlock, 就会把这个线程给唤醒, 造成资源浪费. 这样就有条件变量cond, 条件变量必须和mutex一起用, 并且一个cond只能对应一个mutex. 他支持三个api: wait(cv, mutex), 标记为因为cv而阻塞. signal/notify(cv), 唤醒一个因为cv而阻塞的线程. broadcast/notify_all(cv), 换新所有因为cv而阻塞的线程. 正常的使用方法: // Thread 1 mutex_lock(&amp;mutex); while (!cond) &#123; wait(&amp;cv, &amp;mutex); &#125; // 这里, assert(cond) mutex_unlock(&amp;mutex); // Other Threads mutex_lock(&amp;mutex); // 这里, 做了一些可能会影响到cond的操作 broadcast(&amp;cv); mutex_unlock(&amp;mutex); 这是个模版, 我之前在用golang写Raft的时候也经常使用这个模版. 下面来具体分析了一下这地方干了啥: 重点在wait, wait我的理解是完成了下面这三个操作: mutex.unlock() 让这个线程阻塞, 等待被唤醒. 被唤醒后, mutex.lock() 考虑broadcast的语义, 它会让所有卡在第二步的线程全部启动起来, 这样所有的线程就都会去运行第三步, 争抢mutex. 但是这时候一定只有一个线程能够抢到这个锁. 但是这时候就进入到mutex的语义了: 其他线程虽然没抢到mutex, 又进入了阻塞状态, 但是当mutex被释放后, 他们会因为mutex被唤醒, 从而得到lock, 这一步的唤醒跟broadcast其实是没关系的, 只是因为mutex被释放了. 考虑到第二步这个操作, 如果另一个锁mutex2已经被其他线程lock上了, 那实际上第二步跟mutex2.lock的效果是一样的, 如果把第二步换成这个, 那么mutex2.unlock就相当于broadcast唤醒了所有线程. 但是感觉还是会遇到很多问题, 有时间仔细想想这个跟条件变量的关系吧. 信号量啥的感觉没啥讲的, 就不写了. 哲学家吃饭问题 哲学家吃饭这个经典问题, jyy主张大道至简, 一切都用一个大锁来锁住所有人, 让所有人拿起和放下叉子的过程都是串行的, 然后用条件变量: mutex_lock(&amp;mutex); while (!(avail[lhs] &amp;&amp; avail[rhs])) &#123; wait(&amp;cv, &amp;mutex); &#125; avail[lhs] = avail[rhs] = false; mutex_unlock(&amp;mutex); mutex_lock(&amp;mutex); avail[lhs] = avail[rhs] = true; broadcast(&amp;cv); mutex_unlock(&amp;mutex); 并且jyy主张不要花时间去考虑其他的比较tricky的方法, 他课上也确实没讲. 不过我还是觉得有些方法还是有一些很值得学习的思想在里面的: 比如我在写6.824的时候就意识到, 如果几个线程都需要获取同样的多个锁, 比如几个线程都需要获取锁mutex1和mutex2, 那这些线程在lock这些锁的时候一定要以一个相同的顺序去lock. 比如要么都是先mutex1.lock再mutex2.lock, 要么都是先mutex2.lock再mutex1.lock, 否则这两个线程一定会死锁. 然后我看到了哲学家吃饭问题的这样的解法: 让奇数编号的哲学家都先拿右手的叉子再拿左手的叉子, 偶数编号的相反. 我总感觉这两个的思想是一样的, 就是那种规定了每个锁的优先级, 所有人在加锁的时候都需要按照相同的优先级顺序去加锁. 进一步的, 我深入思考了这个想法, 发现用操作系统那个资源依赖图模型可以说出一些道理: 如果绘制一张图, 图里的每个节点都是一把锁, 那么每个线程的加锁顺序可以用一个这个图上的一组有向边表示. 比如, 两个线程以不同的顺序去加两把锁, 那么这个图就可以表示为: 我认为, 死锁可能发生的充分必要条件是这个图上存在一个环. 比如, 考虑下面的这样一个图: 三个线程分别按顺序锁住: (红色) 1 2 3 4 (棕色) 5 4 6 7 (紫色) 8 7 9 2 这样, 当所有的线程都锁住了他们锁住的第三个锁时, 没有任何一个线程可以锁住最后一个锁, 就死锁了. 如果在哲学家问题中, 让每个人先拿左手边的再拿右手边的, 那这五个锁就会形成一个环. 而我们要做的, 就是控制一些锁加锁的顺序, 让他们永远不可能成环. 比如, 在那个奇偶数的哲学家问题解决方法中, 如果把每个人右手边的叉子标号为这个人的编号, 那么这五个叉子的加锁顺序是这样的: 这是一个有向无环图, 在上面无论如何找不到一条成环的路径. 实际上, 这相当于给每个锁设置了一个偏序关系, 这个偏序至少要保证一个线程需要的所有锁都可以互相比较. 这样, 当一个线程需要很多锁时, 就按照这几个锁的偏序关系去加锁, 这样得到的一定是一个有向无环图. 更一般的做法是, 我可以直接给所有的锁一个全序关系, 这样无论任何线程需要多少锁, 只需要按照这个全序关系的顺序去加锁就行. 比如在哲学家吃饭问题中, 完全可以给每个叉子编号之后, 让每个人先拿编号大的再拿编号小的, 这就构造了一个全序关系. 也就是除了第5个哲学家先拿左手再拿右手, 其他的都先拿右手再拿左手, 这样就可以避免死锁.","categories":[],"tags":[]},{"title":"并发中的互斥","slug":"mutex","date":"2022-08-20T16:32:10.000Z","updated":"2022-08-20T16:58:21.333Z","comments":true,"path":"2022/08/21/mutex/","link":"","permalink":"https://orangecheers.top/2022/08/21/mutex/","excerpt":"好家伙, 我已经三个多月没写东西啦! 最近两天先写点基础的, 这两天在看jyy的操作系统课和6.S081, 恶补一下操作系统的知识. 过几天写一下这个学期一直在研究的分布式系统, Raft啥的.","text":"好家伙, 我已经三个多月没写东西啦! 最近两天先写点基础的, 这两天在看jyy的操作系统课和6.S081, 恶补一下操作系统的知识. 过几天写一下这个学期一直在研究的分布式系统, Raft啥的. 互斥 互斥就是禁止多个线程同时访问同一个资源, 这个资源叫做临界资源. 并行编程最大的几个问题之一是多个线程的执行流会被来回切换, 你永远想象不到一个线程会在什么时候被打断. 还有就是编译器, 现代处理器都会在不同级别上乱序执行, 不过这个也不是今天讨论的重点, 这个主要靠barrier去解决. 比如这样的: int locked = UNLOCK; void critical_section() &#123; retry: if (locked != UNLOCK) &#123; goto retry; &#125; locked = LOCK; // critical section locked = UNLOCK; &#125; 一个失败的锁的尝试, 多个线程可能同时判断到locked为unlock. 重点在于处理器不保证load+store的原子性 Peterson算法 Peterson算法实现了两个线程的互斥, 不需要任何复杂原子操作. 两个线程争夺临界区: 每个线程自己有个标志, 临界区有个标志turn 把自己的标志亮起来. 把临界区的标志turn改为 对方. 如果对方的标志亮起来, 并且turn是对方, 就等待, 否则进入临界区. 出临界区, 熄灭自己的标志. 感性理解: 如果只有一个线程想要进入临界区, 那显然正确. 两个线程同时想要进入临界区, 两个线程都会把自己的标志亮起来, 并且去修改turn. 先修改turn的那个线程把turn改为了对方, 但是后面另一个线程会把自己的turn改回自己. turn决定了到底谁进入临界区, 手快🈶️, 手慢🈚️. 感性理解正确性: 如果两个线程都想访问临界区, 但是一个线程A比较快, 把turn改为了对方: 如果另一个线程B还没有亮起自己的标志, 那A就直接进了, 一会B亮标志再改turn的时候会因为turn被自己改成了A而阻塞, 直到A退出临界区, 灭掉了A的标志. 如果另一个线程已经亮起了自己的标志, 那A会阻塞到B把turn改为A之后, A进入临界区, B同样会被阻塞. 也就是说, 因为大家都会把turn改为对方, 所以大家都会阻塞直到所有人都改了turn, 这时候就根据turn是谁决定谁进入临界区. 一些思考: 能不能先改turn, 再亮标志? 肯定不行, 假如A先把turn改成了B, 然后因为这时候A没有亮标志, 所以B可以直接改turn为A+亮标志+进入临界区, 这时候A因为看到turn为自己, 也可以直接进入临界区, 就寄了. Peterson算法属于比较一般的互斥算法, 只要内存模型是顺序一致的(Sequential Consistent), 就可以实现两个线程的互斥, 不需要任何复杂原子性的操作. 类似的算法还有dekker, 都比较复杂, 现代操作系统一般可以依赖于硬件实现的原子操作来简化互斥. 为了防止编译器和处理器在不同级别上的乱序优化, 可能需要在某些地方加不同级别的Barrier. Model Checking 使用工具来检验模型的正确性! 其实就遍历多个线程状态机转移的每一种情况, bfs枚举. 可以使用python来模拟这个操作, 每一行语句后面加一个yield, 每一个线程包装成一个generator, 一次__next__() 就相当于一个线程执行了一步, 每一行都相当于一个原子操作. 现代软件自动化测试工具会加很多优化, 比如如果两个线程的某几步涉及到的内存完全不相关, 那他们这几步的顺序是无所谓的…诸如此类. 还可以用来检查filesystem的正确性, 和其他内存模型下的算法正确性… 锁 但是Peterson的假设太弱了, 没有任何复杂的原子操作, 只有load和store. 自旋锁是加了一个原子指令: lock. 互斥锁是增加了操作系统作为调度者. Futex是结合了自旋锁和互斥锁的优点, 目前使用的Mutex很多都是Futex. 自旋锁 (Spinning Lock) lock xchg %1, %2. 原子性的交换%1和%2. 实际上这就是一个load+store: load了%1到%2. Store了%2到%1. 如果一个有共享内存a, 0代表未上锁, 1代表上锁. 那么让b为1, xchg a, b, 检查a 如果b是1, 说明本来a本来就是1, 说明已经有人上过锁了, 返回xchg重试. 如果b是0, 说明本来a是0, 没有人上锁, 现在我们把a换成了1, 我们可以安心访问临界资源了. 从临界区退出后, 把a改回0. 自旋锁的缺陷 访问共享变量的自旋会出发多处理器之间的同步, 拖累性能. 一个线程抢占到锁之后, 其他处理器都在空转! 获得自旋锁的线程可能会被操作系统切换出去! 其他线程啥也别想干. 自旋锁的使用场景 临界区几乎不拥堵, 不太会出现多个线程抢占的情况. 持有自旋锁的时候可以禁止流切换, 但是一般的程序也没这个权利. 所以基本只有在操作系统内核中才会使用自旋锁: 操作系统可以关闭中断和抢占, 保证锁的持有者很快就会释放锁 但是即使这样也很难用好自旋锁. Lock指令 x86的lock 在三十年前的80486时期就已经支持双路处理器, 支持lock了. lock指令会保证, 在lock之前的所有store都已经写入内存. 在早期缓存是所有处理器共享的时候, 一个处理器执行lock指令时, 会把总线锁上, 这样其他处理就不会干扰他的原子操作. 但是现代处理器内部就有缓存, x86就要在L1级别的cache上保证一致性. 所有的L1 Cache都是串起来的, 一个处理器执行了原子性更改内存的操作, 需要更改所有出现这个块的缓存. 这也是x86背负的巨大历史包袱之一. RISC-V的另一种lock实现 常见的原子操作基本都分为三步: load. exec, 即处理器自己在进行计算. store. RISC-V认为exec操作可以多次进行, 影响不大, 所以使用了Load-Reserved/Store-Conditional策略: 在执行原子操作前, 把需要影响到的内存打上Reserved标记. 如果计算期间有中断, 或者有其他处理器写入, 标记都会清除. store时判断是否有标记, 没有标记就重试. 互斥锁 (Mutex) 互斥锁可以让没抢到锁的线程被操作系统阻塞, 操作系统可以去执行其他线程. 当然, 一般的用户程序也没这个权利, 所以互斥锁需要通过系统调用进入内核. syscall(SYSCALL_lock, &amp;lk); 尝试获取锁lk, 如果失败, 进入阻塞. syscall(SYSCALL_unlock, &amp;lk); 释放lk, 唤醒其他因为lk而阻塞的线程. 操作系统的操作: 先获取锁的线程, 得到锁, 操作系统让lk=1. 后获取锁的线程, 进入阻塞队列. 得到锁的线程释放锁后, 唤醒阻塞队列中的一个线程执行. 如果阻塞队列为空, lk=0; 操作系统使用自旋锁来保证自己的操作是原子的. Futex 自旋锁的两种情况: 更快的fast path: xchg成功, 进入临界区, 开销很小. 更慢的slow path: xchg失败, 浪费资源自旋. Mutex的两种情况: 更快的slow path: 上锁失败, 直接阻塞. 更慢的fast path: 无论如何都要进入内核. Fast Userspace muTexes (Futex) 的折衷: Fast path: 一条原子指令, 上锁成功直接返回. Slow path: 上锁失败, 阻塞. Linux大范围地使用Futex代替Mutex. 在FreeBSD, Linux中的Golang里的sync.Mutex, 实际上也是Futex.","categories":[],"tags":[]},{"title":"半夜想写一点东西","slug":"20220503","date":"2022-05-02T16:55:12.000Z","updated":"2022-05-02T17:01:43.018Z","comments":true,"path":"2022/05/03/20220503/","link":"","permalink":"https://orangecheers.top/2022/05/03/20220503/","excerpt":"半夜想写一点东西.","text":"半夜想写一点东西. 距离上一次写文章已经过去一个多月了, 虽然我觉得我已经半年没怎么认真写过东西了, 可能是因为上次写东西也没有多认真写, 学到的东西也没有多么的用到, 该解决不了的问题还是解决不了, 该诉诸玄学的问题我还是选择了诉诸玄学, 只不过某些时候我开代理打不开网站的时候我会更自信的认为这又是个玄学问题罢了. 这学期开学前, 我仔细思考了我从高中到大学的生活, 感觉我现在的大部分遗憾都是在一开始选择了一条更艰险的路, 但是要么缺少定力, 要么缺少勇气, 总是在这条路走一半的时候或发现已经耽误了太多时间, 或发现自己没有了走下去的勇气, 或走一半就松懈下来, 最后难免匆匆忙忙地回归主流, 两边都没有照顾好. 我当时决定这学期不能这样下去. 这学期的最主要的中期目标有三个, 我当时这样想: 期末考试考好. acm努力训练, 比赛正常发挥. 保研找个喜欢的地方. 其实保研这事对于寒假结束的我来说还太远了, 并且这件事更多的是前两件事的结果, 所以我的重点也就放在了前两件事. 如果我期末考试考的好, 排名再往前进个1%或2%, 然后acm再换个牌子拿, 至少我感觉我的大学生活没有太大的遗憾了. 当时我的规划是, 从寒假结束开始, 到期末考试结束, 这十几天的时间我是不会去考虑acm的事情的. 但是时间越近, 我对acm还是破铜烂铁的恐惧就越深, 就越去惋惜从去年济南结束后这段我本不该花在acm上的时间. 尽管最后考试过程中的自我感觉比较良好, 但是等到一门比一门离谱的成绩出来的时候我还是觉得不敢相信. 这应该是我过去五个学期最黑暗的考试周, 因为没有哪一学期的期末成绩比这学期更加绝绝子. 至此, 我的第一个目标总算是失败了. 可能上天还是公平的, 尽管我确实觉得期末考试考的还可以, 但是我复习的时候也确实不怎么认真, 也失去了大二上学期速成期末的时候那种即使学不完我也不能漏掉每一个细节的完美主义, 可能这就是让我期末变成这样的直接原因吧. 名次没了, 如果acm还是之前那样的成绩的话, 我的保研估计也就不需要去期待什么了. 本着这样的心情, 我开始了我这辈子最后一次的acm赛前准备阶段. 这段就不说了, 每次想起这些事情还是只能靠精神胜利法安慰自己, 相信这一切都是上天最好的安排, 只不过这次不太信了, 但是我还是不敢允许我不相信. 只能说这段时间确实学到了许多, 比赛过程中我确实也感觉到自己的进步. 尽力了, 但是可能还是差点吧, 如果我再聪明一点, 如果我做题再多一点, 如果我把我想交代的事情全都交代清楚了, 可能就不会这样了. 至此, 我的第二个目标也终于是失败了, 可以预见的是我的第三个目标也不会有多好的结果, 我的大学终究还是变成了跟高中一样, 充满了遗憾和不甘, 可能我的命运就是这样的吧. 总感觉自己的性格注定了我的生活不会轻松, 我总是把自己的累归咎于自己目前在准备的事情, 觉得这件事情结束后我就不会这么累了. 可是我现在发现了, 无论什么时候我都会太在意别人的感受和评价, 无论做什么事情我都会考虑太多太多乱七八糟的情况和后果最后一点都不敢行动, 无论什么时候我看到某导在群里的所言所行我都会愤怒痛心为什么我生活的世界会有这样的人, 无论做什么事情我都会被脑子里不属于这件事的其他的胡思乱想和担忧占用掉大部分的精力. 我总是相信我可以寻找一个自己的美好世界, 但是当我看到肮脏的东西却无能为力时, 只能不断的怀疑自己究竟能不能找到一个这样的地方, 然后安慰自己等换个地方就好了. 最近也不是什么都没学, acm结束后我又总是想尽可能的多学一点来弥补自己acm耽误掉的时间, 但是总感觉效率还是不高, csapp也不在看了, 6.824的东西刚开始写Lab 2, 给自己订的去联系老师的ddl也快到了, 但是自己还是不怎么敢去联系, 还是觉得自己还可以变得更好, 可惜时间不等人了, 而且我也不敢保证这是不是又是个把自己封在舒适圈的借口. 现在每天唯一稳定的快乐就是npy了, 可能我最近生活中所有让我感到高兴的事情都是关于她的吧. 想了想好像真是的. 文笔不好, 我估计也没人读到这. 如果真有人能读到这, 真的委屈您了.","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"透明代理","slug":"fakeip","date":"2022-03-21T14:01:05.000Z","updated":"2022-03-21T14:05:20.921Z","comments":true,"path":"2022/03/21/fakeip/","link":"","permalink":"https://orangecheers.top/2022/03/21/fakeip/","excerpt":"博客换了个服务商, 之前在Digital Ocean上的, 太贵了养不起了, 换了个便宜VPS, 期末考试一直没来得及迁移. 数据库考试给我整麻了, 不会真有人给局部变量上了个锁吧. 前几天找了篇文章学习了一下透明代理的fake-ip, 写了个这东西总结一下, 然后博客今天才修好, 今天再传上来. 想写的东西挺多的, 但是好累, 我又变懒了.","text":"博客换了个服务商, 之前在Digital Ocean上的, 太贵了养不起了, 换了个便宜VPS, 期末考试一直没来得及迁移. 数据库考试给我整麻了, 不会真有人给局部变量上了个锁吧. 前几天找了篇文章学习了一下透明代理的fake-ip, 写了个这东西总结一下, 然后博客今天才修好, 今天再传上来. 想写的东西挺多的, 但是好累, 我又变懒了. 不使用代理 浏览器向操作系统发送DNS查询 查询到ip后, 建立tcp连接. 使用代理但是没有远程服务器 浏览器发现有代理, 直接向代理软件使用socks5发送流量, 流量里包含了域名. 代理软件使用自己的或操作系统的dns服务解析dns, 建立tcp连接. 使用代理, 直接全局流量转发到远程服务器 浏览器发现有代理, 直接向代理软件使用socks5发送流量, 流量里包含了域名. 代理软件抽出域名和其他数据, 把数据重组为ss协议发送到远程服务器. 远程服务器使用dns查询, 这个是由远程服务器的操作系统提供的dns查询. 使用代理, 但是本地分流 分流的时候, 如果是域名分流, 那代理软件直接比对域名就行了, 如果发现这个域名应该是直连, 那本地请求dns建立连接就行. 如果发现要转发到远程的服务器, 那就连着域名封装到ss里发过去, 本地不需要解析. 如果是ip分流, 就比较麻烦了. 本地的代理一定要进行一次dns解析, 因为需要拿到ip进行分流. 如果发现是直连, 就用刚刚解析的IP建立连接就行. 如果是发送给远程服务器, 这个ip就没用了, 封装进ss的还是域名, 解析还是由远程服务器解析, 跟本地解析的ip地址没关系. 使用TUN/TAP 这种东西是透明的, 也就是说浏览器不知道自己经过了代理, 所以也不需要在浏览器上配置代理, 相当于强制让浏览器走了代理. 浏览器请求DNS, 调用操作系统的DNS服务. 操作系统会向系统级别设置的DNS服务器请求, 有些代理会把这个DNS服务器设置为自己, 127.0.0.1, 但是无所谓, 因为操作系统发出的DNS请求都会被代理截获. 代理服务器可以选择把这个DNS请求发出去, 或者使用自己的dns服务返回给操作系统. 浏览器拿到这个解析, 再建立tcp连接, 这个连接同样被代理服务器截获. 代理服务器拥有之前发送的dns请求和返回结果, 就可以确定这个tcp连接刚刚发的是哪一个dns请求, 就能确定这个tcp连接的对应域名. 可以直接把域名封装进ss发送给远程服务器. 远程服务器再进行一次解析. 也就是说, 如果使用域名进行分流, 本地代理软件的返回的dns结果是没有用的, 而且还多了一次dns查询, 可以直接让本地代理软件返回一个假ip, 应用程序就能立刻建立tcp连接. 这个就是Fake-IP. 如果使用IP进行分流, 代理软件也可以先返回一个假IP, 然后再去等待DNS回应. 返回假IP后代理软件会维护一个Fake-IP和域名的对应表, 等到操作系统再发起TCP请求的时候从他请求的IP找到对应的域名, 封装进ss发出去. 如果是使用Redir-host模式, 代理会等真实的DNS请求回来的时候把真实的DNS发送给操作系统, 这样即使有些TCP流量不走代理软件, 因为他有真实的ip, 所以也是能用的. 但是Fake-IP模式所有流量必须都走代理, 因为他tcp头的那个目的地址是瞎编的, 必须要给代理软件把流量改成域名封装进ss里交给远程服务器来解析连接, 直接连肯定连不上瞎编的ip的. 缓存问题 在Redir-host模式下, 如果操作系统或浏览器缓存了DNS解析记录, 代理软件就不会收到DNS解析请求, 只收到一个含有目的ip地址的TCP连接, 这样代理软件不会知道域名是什么, 基于域名的分流策略会失效. 但是基于ip的分流策略还有效. 在Fake-IP模式下, 操作系统或浏览器缓存了DNS解析记录也问题不大, 因为这时候有Fake-IP与真实域名的表, 可以用假ip查出域名. 但是这样从Fake-IP模式切换出来会有很大的麻烦, 所以很多软件都把Fake-IP返回的DNS解析记录的TTL设置为1, 尽力避免Fake-IP被缓存. 如果使用了Fake-IP, 操作系统试图访问一个不存在的域名时, 并不会收到DNS解析错误的信息, 因为DNS解析错误的只会在远程代理服务器上产生, 操作系统不会收到任何信息. 如果操作系统缓存了Fake-IP, 但是代理软件的Fake-IP表丢失, 也会导致打不开网页.","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"CF763 div2 D.Robot Cleaner Revisit","slug":"cf763d2D","date":"2022-01-06T09:43:39.000Z","updated":"2022-01-06T10:32:00.000Z","comments":true,"path":"2022/01/06/cf763d2D/","link":"","permalink":"https://orangecheers.top/2022/01/06/cf763d2D/","excerpt":"https://codeforces.com/contest/1623/problem/D 最近在跟队友复健cf, 三个人开黑vp, 感觉状态还是不太行. 这题感觉还挺有意思, 还没过的时候就想如果真的是这样做的一定要写篇文章记录一下, 然而这题是元旦过的, 我现在才开始写, 拖延症晚期了属于是.","text":"https://codeforces.com/contest/1623/problem/D 最近在跟队友复健cf, 三个人开黑vp, 感觉状态还是不太行. 这题感觉还挺有意思, 还没过的时候就想如果真的是这样做的一定要写篇文章记录一下, 然而这题是元旦过的, 我现在才开始写, 拖延症晚期了属于是. 前几天刚把自己的win11重装了一遍, 因为感觉莫名其妙的小问题太多了, 也不知道是软件的问题还是系统的问题, tim和qq在打开打开文件的对话框的时候一定闪退. 还有其他小问题我也记不清了, 反正这些问题我都单方面归咎于傻逼win11了. 而对于一个恶人我只需要记住他最恶的一件事就行了, 就是tim和qq在打开打开文件的对话框的时候一定闪退. 重装了系统之后果然tim打开打开文件对话框的时候不闪退了, 我刚为这件事弹冠相庆没多长时间, 他又闪退了. \"历史的车轮总是能接受倒退的\", 但是当时在写各种大作业, 就没着急换回win10. 但是当我把我计算机图形学作业发给老师之后, 我又发现他又不闪退了, 他的心好难捉摸. 总之我现在就安分地用着这个win11, 去typora官网上下个历史版本, 趁着nodejs还在安装的时候先写个题解. 题目原文: tmd, 我刚想把这张图发到qq上在保存下来压缩图片, 他又崩了, 麻了. 大概题意就是, 有一个扫地机器人在一个网格, 他有一个初始位置, 然后他每秒可以移动(+1, +1), 但是如果有一个坐标方向上他在墙旁边了, 他的下一步对应坐标的增量就是-1. 这样循环的移动. 有一个垃圾, 他在另一个位置上, 扫地机器人每次移动之前, 都有\\frac{p}{100}的概率扫掉对应一行和一列的垃圾. 问期望多长时间他能扫掉这个垃圾. 因为这场比赛第一题是个不带概率的, 每次一定会扫掉垃圾, 就直接把x和y坐标分开看, 看哪个坐标最先到对应的行和列就行. 所以这题我也直接考虑把两个坐标分开看, 确实推出来了一些东西, 我可以得到这个问题在一维上的公式, 但是这样两个一维的问题还是合并不到一个二维问题上, 所以根据经验这时候就需要直接考虑二维问题. 这样的递归求期望题很多都用了一个期望的技巧, 就是一个问题的期望是固定的, 而且这个问题可以化成很多相同的子问题, 并且这些子问题能够回到原问题的期望上, 这样就可以找到一个关于这个期望的方程, 直接解了就行了. 这个问题感觉也可以这样做, 因为这个机器人的状态一定最多只有 4NM 种, 即每个位置和每个位置上的四个方向, 并且当前的状态仅于上一个状态有关, 所以只要两个状态相同, 他们之后的所有运动轨迹一定也相同. 这样的话根据抽屉原理, 这个机器人的运动状态的循环节长度一定小于 4NM . 我们令初始状态的答案为 E(x_0, y_0, 1, 1) , 即起点在 (x_0, y_0), 两个坐标轴的增量(即方向为) (+1, +1). 只要我们找到状态于状态之间的转移, 就可以列出一个从起点状态回到起点状态的方程, 解出这个方程就行了. 那么我们模拟这个机器人的运动轨迹, 然后考虑转移, 用 S 表示当前状态, 用 S' 表示下一步的状态. 如果 S 这个状态扫不到垃圾, 那么一定有: E(S) = E(S') + 1 , 如果 S 状态可以扫掉垃圾, 那么有 p 的概率, 直接结束, 这个结果对期望时间的贡献为 p \\times 0 = 0. 剩下 1-p 的概率, 他扫不到垃圾, 需要转移到下一个状态的期望, 即: E(S) = \\overline p\\times(E(S') + 1) 这样一直走下去, 等到 S' = S_0, 就可以列到一个方程. 比如这样一个状态转移, 打√的代表可以扫到垃圾. 那么我们可以列出一个这样的方程: 1 + \\overline p(4+\\overline p(1+x)) = x 对于初始位置在(1,2), p = 25\\% 上的这样一个例子, 可以列出方程: \\frac{3}{4}(1+\\frac{3}{4}(1+\\frac{3}{4}(1+\\frac{3}{4}(1+x)))) = x 可以看出, 方程全部都是 \\overline p (a + ...) 这样的递归形式, 对于每一个扫到垃圾的状态, 方程会增加一层, 对于扫不到垃圾的状态, 只会让当前层的常数项+1. 实际上, 对于连续的一堆扫不到垃圾的状态, 他对方程的贡献都是连续的+1, 变成了一个常数项, 所以可以直接在可以扫到垃圾的时候看一下距离上一次扫到垃圾的时候经过了多少扫不到垃圾的状态, 然后直接把常数项加到方程里. 最后的问题就是如何解这个方程, 这个方程其实直接一层一层解开就行了. 但是可以观察到这个和什么秦九昭算法比较像, 其实就是可以把这个方程展开, 展开成一个多项式的形式, 例如对于倒数第二个样例, 列出的方程为: 1 + 0.9(4+0.9(2+0.9(1+x))) = x 左边全部展开, 整理得: 0.9^0 \\times 1 + 0.9 \\times 4 + 0.9^2 \\times 2 + 0.9^3 \\times 1 = (1 - 0.9^3) x 解得 x = \\frac{6949}{271}, \\frac{6949}{271} \\% 1000000007 = 332103349. 代码: // // Created by Orange_Cheers on 2022/1/1. // #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> #define MAXN 1005 #define mul(a,b) (((a%mod) * (b%mod))%mod) #define add(a,b) (((a%mod) + (b%mod))%mod) using namespace std; using lovelive = long long int; const lovelive mod = 1e9+7; int N, M, stx, sty, edx, edy, P; lovelive ksm(lovelive a, lovelive k) &#123; if(k == 0) return 1; lovelive ha = ksm(a, k/2); if(k%2 == 1) &#123; return mul(ha,mul(ha, a)); &#125;else&#123; return mul(ha, ha); &#125; &#125; int main() &#123; const lovelive inv100 = ksm(100, mod-2); cin.tie(nullptr); ios::sync_with_stdio(false); int T; cin >> T; while(T--) &#123; cin >> N >> M >> stx >> sty >> edx >> edy >> P; int x, y, dx, dy; x = stx, y = sty, dx = dy = 1; if(x + dx > N || x+dx &lt; 1) dx *= -1; if(y + dy > M || y+dy &lt; 1) dy *= -1; int sdx = dx, sdy = dy; lovelive cnt = 0; static vector&lt;lovelive> v; v.clear(); do&#123; if(x == edx || y == edy) v.push_back(cnt), cnt = 0; x += dx; y += dy; if(x + dx > N || x+dx &lt; 1) dx *= -1; if(y + dy > M || y+dy &lt; 1) dy *= -1; cnt++; &#125;while(!(x == stx &amp;&amp; y == sty &amp;&amp; dx == sdx &amp;&amp; dy == sdy)); v.push_back(cnt); lovelive ans = 0; lovelive np = 1; for(int i = 0;i &lt; v.size();i++) &#123; ans = add(ans, mul(v[i],np)); if(i == v.size()-1) &#123; ans = mul(ans, ksm(((1 - np)%mod + mod) %mod, mod-2)); break; &#125; np = mul(np, ((1 - mul(P, inv100))%mod + mod) % mod); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://orangecheers.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"2021MSC ACM组新生赛获奖同学来领奖品啦/ACM组数模组队版","slug":"2021-freshmen-awards","date":"2021-12-14T01:48:10.000Z","updated":"2021-12-14T06:54:28.000Z","comments":true,"path":"2021/12/14/2021-freshmen-awards/","link":"","permalink":"https://orangecheers.top/2021/12/14/2021-freshmen-awards/","excerpt":"MSC这边有三种奖品: T恤 马克杯 帆布手提袋","text":"MSC这边有三种奖品: T恤 马克杯 帆布手提袋 特等奖同学可以获得T恤+剩下两个选一个 一等奖同学可以获得T恤 二等奖同学可以获得马克杯或者帆布手提袋 三等奖同学可以获得帆布手提袋 T恤: 马克杯: 帆布手提袋: 特等奖同学私聊我T恤尺寸(M/L/XL/2XL/3XL)和剩下两个选什么. 一等奖同学私聊我T恤尺寸. 二等奖同学私聊我选马克杯还是帆布手提袋. 三等奖同学就发帆布手提袋啦. 也可以自愿把奖品换成低等级奖品的, 跟我说一声就行. 新生赛终榜和获奖情况: https://acm.xidian.edu.cn/freshmen/2021/ranklist/ 最后, 大家可以在评论区找数模队友! 介绍一下自己, 然后注意留个qq号就行啦","categories":[{"name":"私号公用","slug":"私号公用","permalink":"https://orangecheers.top/categories/%E7%A7%81%E5%8F%B7%E5%85%AC%E7%94%A8/"}],"tags":[]},{"title":"ccpc2021网络赛游记","slug":"ccpc2021_network","date":"2021-09-01T08:55:56.000Z","updated":"2021-09-06T03:52:36.000Z","comments":true,"path":"2021/09/01/ccpc2021_network/","link":"","permalink":"https://orangecheers.top/2021/09/01/ccpc2021_network/","excerpt":"西电的网其实还行, 虽然也是一直打不开, 但是最起码我们的题目都交上去了, 听说有的学校5个小时就没打开过.","text":"西电的网其实还行, 虽然也是一直打不开, 但是最起码我们的题目都交上去了, 听说有的学校5个小时就没打开过. 本来我说28号返校, 把买火车票的记录往Double Rainbow群里一发, hx提醒我28有ccpc网络赛, 他说他29号走. 我说这么重要的比赛当然要线下打, 就唆使他们跟我一起27号回去了. zirrtu家就在西安, 所以他没什么紧张的. zirrtu家在四号线旁边, 去学校的话要换5号线再换6号线, 所以我们约好在5号线西工大站见面. 我和hx坐的一班火车, 还在一个车厢, 我本来说让他把票退了, 跟我一起买, 这样可以坐一起. 但他说他要是自己买的话就要自己付钱, 就没跟我一起买. 下了车, 坐二号线去南稍门站, 进站的时候发现我们没安检就进地铁站了, 我认为这是因为我们没出火车站所以才这样. 进地铁站扫码的时候有一个出站的二维码和一个坐2号线的二维码, 所以应该是坐地铁这样也不算出站. 到南稍门换乘, 上了5号线, 还有一站到西工大的时候zirrtu说他快到了, 还有一站, 我合理推断我们三个在一个地铁上. 果然, 一下车出车厢门就看到他了. zirrtu说他的导师总以为他是计科专业的, 他说他不会操作系统他导师就说他对课上的知识理解不深, zirrtu说他对他的课上的天线原理理解很深, 可以做一个收音机, 能收八个台. 在六号线上, zirrtu说他核酸是14天前的, 我们俩有点震惊, 觉得他这个不太行, 毕竟学校要求的是48小时之内. 下了地铁hx让zirrtu去医学中心做个核酸, 我跟zirrtu就去了, hx在地铁站看包. 医学中心人还挺多, 我跟他排了二十分钟的队, 排队的时候zirrtu说他刚知道芜湖和蚌埠都是安徽的, 他很震惊为什么安徽能有两大抽象城市. 快到他的时候我去旁边坐着等他了, 等他的时候还看到一个老外坐轮椅上, 穿着University of Oxford的衣服, 好像挺强的. 推着他的人叫了一辆救护车, 把他推上去, 走了. 过了一会, 我在群里问他做好了没有, 他说做好了, 快到地铁站了. 我直接一个?发出去了, 我坐医院等你呢. 他说那你快出来, 他就在医院门口. 然后hx打车回学校, 滴滴接单之后我打电话问司机能不能装得下三个行李箱, 司机说三个装不下, 我说有两个挺小的, 司机说到那看吧. 等了一会司机说他到了, 但是没看见人, 然后才发现hx选错上车点了, 我们在C口, 他选的B口. 过去之后, 司机还说装不下, 我说这装着试试, 司机抱起我的箱子说,\"你看你这一个大的就占满了\", 然后放车子里, 发现只占了一半空. 然后我在我箱子上面和旁边把另外两个小箱子放下了, 还把后备箱门关上了. 在车上, zirrtu说他的返校申请导员还没批. 我说你直接给你导员打电话, zirrtu说他这次返校申请写的导员不是他的导员, 很奇怪. 然后zirrtu打电话给他导员, 他导员把返校申请上写的审批人的电话给他了, zirrtu打电话给那个人, 那个人没接. 到北门了, 那个人还是没接, 又打电话给他导员, 导员说他没啥办法, 让他继续给那个人打电话, 然后还解决了zirrtu的疑惑, 原来是他导员升职了, 不再是导员了, 所以那个人成了zirrtu的导员. zirrtu给那个人打了十几个电话, 那个人终于接了, 然后特别凶地说了三个字\"我有事\", 就给挂了. 我们三个在门口等了十几分钟, 那个人终于打电话过来了, zirrtu说他返校申请没批, 那个人说他疫情通没填够14天, 不让他返校. 然后我跟他说, 可以我们把他行李拿走, 让他偷渡进去, zirrtu说他刚刚有可能保研, 怕给整没了, 就没敢. 然后我和hx帮他把大件行李拿到hx寝室, 他一个人骑个小黄车去地铁站了. 然后我们本来约去师大附中打, 但是那边好像不太确定能不能进, 就算了. 第二天我和hx去G346, 进去用我电脑外放开了个qq语音, 让zirrtu进去了, 我这边把声音调到了最大, 他那边把他一千多块钱的麦的增益调了好高我们俩才听到, 不过测试的时候旁边有点吵, 等到大家安静的时候全教室都能听到他的声音. 我坐在了第二排, 本来以为前面没人坐了, 一会王老师他们队坐我们前面了. 又要被气场压制了. 还差5秒钟开局, 就遇到了经典问题: 不过西电的网还行, 刷了一会就刷出来了. 上来我开了第9题, 就是两个前缀和套成pair就行, 不过第一次我用了multiset, 不知道怎么回事第一发T了, 这时候hx把第1题过了, 然后我换成map就把第9题过了, 贡献一发罚时. 然后一起做第6题, 研究了二十分钟吧我发现一个惊天大秘密, 就是连续四个完全平方数, 最后一个加上第一个减去中间两个居然永远等于4! 然后用这个东西就把这题过了. 然后一起开第7题, 想了三四十分钟吧, hx发现g(x)最大只有六十多, 可以枚举, 然后我说把g(x)看成常数剩下的就是个二次函数, 直接乱搞求极值就行, zirrtu写了个暴力, 我写好之后对拍了一下, 发现了一堆小问题, 改好了之后交了就过了. 然后一起开第二题, zirrtu说这名字是啥东西, 我说这个不就是TDM, 时分复用, 唤醒了他的DNA. 然后我发现这玩意一个最多100 \\times \\mathrm{LCM}(1,...,12)就会循环, 而且\\mathrm{LCM}(1,...,12)只有两三万的样子, 所以直接把这个字符串写两遍循环节, 然后来个双指针就行了. 感觉比上一题简单多了. 这时候服务器已经不太行了, 都是zirrtu在那边先把提交页面刷出来等我和hx改好, 然后给他让他交. 我和zirrtu搞这题的时候, hx交了一发11题TLE了, 剩下感觉也没什么题可做, 我也不会dp, 就把希望寄托在hx上了, 不过我分析了一波, 好像他即使不做出来那题也基本能进现场赛, 所以我就没太在意. 感觉那天下我状态不错, 输出挺多的. 我和zirrtu都在给hx刷提交页面, 我的提交页面用掉了就用zirrtu的, 我接着刷提交页面. 最后十分钟, hx把那题过了, 他好强. 最后排名西电第三, 前面一个7题一个6题, 我们队也是6题, 然后看了一下即使我们最后那题不出也是5题第一名, 也是第三名. 比赛结束才知道最后一题是原题, 好傻逼. 本来以为这次ccpc现场赛稳进了, 结果又要重赛了, 下次不知道还有没有这么好的状态. 最近托rx的福, 在210搞了个工位, 每天有效学习时间指数级增长, 开始复健了, 马上就又有一堆比赛了, 还要学CV的东西.","categories":[{"name":"游记","slug":"游记","permalink":"https://orangecheers.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"事情多到爆炸也想折腾一下家里的网络","slug":"network","date":"2021-08-23T13:02:33.000Z","updated":"2021-08-24T14:11:01.000Z","comments":true,"path":"2021/08/23/network/","link":"","permalink":"https://orangecheers.top/2021/08/23/network/","excerpt":"最近事情多到抑郁, 但是我这种佛人再忙也要绞尽脑汁想点没用的事给自己做.","text":"最近事情多到抑郁, 但是我这种佛人再忙也要绞尽脑汁想点没用的事给自己做. 为了让家里各个角落都有wifi用并且有个地方能跑一些奇怪的网络服务, 我一两年前搞了个工控机当软路由用, D2550+从高一买的神船上拆下来的4g内存条刷了个openwrt系统, 我之前写玩具Ray Tracer的时候还在这个神机上出过一张图. 我们家之前是router+3AP结构, 主路由是那个软路由, 然后还有三个硬路由当AP用. 其中一个AP是无线桥接上去, 另外两个是有线桥接. 后来无线桥接的路由器死了, 也懒得补上去, 就保持着router+2AP的结构了. 光纤进来的时候接进了一个光猫, 这个光猫应该是集成了调制解调器和无线路由器的功能, 而且强制把PPPoE拨号放在了这上面. 但是这玩意一看就属于性能羸弱的类型, 而且这个超级密码应该是联网自动更新的. 我去恩山上面找到个在安徽移动上班的大神, 查到了自己家光猫的超级密码, 进去反手改一个桥接. 然后用主路由WAN口连上光猫的LAN, 把拨号, DHCP服务器和一些奇怪的服务全部搬到了主路由上. 然后主路由的LAN接到AP1的LAN, AP1的另一个LAN接到AP2的LAN上, 相当于把这俩硬路由当成了交换机用, 全家都在一个网段(192.168.8.1/24). (众所周知, 邦邦是路由器) 现在遇到的问题就是, AP1, 也就是在我卧室的这个硬路由, 他只有两个LAN口, 全部都被用了. 现在我想把一个台式机放在这里有线接入都没有地方接了. 现在初步一想, 有两个方法: 在软件层面上把AP1的WAN口强行改成LAN口. 把AP1和AP2调换一下位置, AP2的LAN口多. 第一个方法硬路由的原生固件肯定是不支持的, 如果想要做的话, 需要给这个硬路由也刷上openwrt才有可能. 刷硬路由太折磨人了, 而且固件还有可能出问题, 所以就放弃了. 看起来第二种方法好像更简单一点, 按理说, 我只需要把这俩路由器调换一下位置, 连管理界面都不需要进. 但是我们家两个AP的的wifi的SSID不一样, 为了让wifi还停留在原地, 我还想调换AP的同时把这俩wifi的SSID调换一下. 这时候我遇到一个大问题, 我忘了两个硬路由的LAN口地址了. 因为是桥接网络, 所以两个硬路由的DHCP服务器一定是要关掉的, 这样我就真不知道怎么拿到他们的IP地址了/dx. 只能把两个路由器重置一下, 默认他们的DHCP服务器是开的, 用个网线直接连电脑就能拿到网关地址, 然后就能进管理界面了. 进去之后关DHCP, 设置两个硬路由LAN口地址分别为192.168.8.2和192.168.8.3, 192.168.8.1是给主路由用的. 把SSID换一下, 就完成了. 灵异事件出现了, 之前工作的好好的超长网线这时候不起作用了, 超长网线另一端的AP根本访问不到主路由. 我以为是超长网线的问题, 但是我把超长网线接到光猫的LAN口上的时候, 那边AP接入的设备甚至还能分到光猫里DHCP服务器分来的192.168.1.1网段的IP. 合理推断, 应该是换来的这个硬路由的问题, \"带不动\"这根长网线. 无奈, 只好再换回来. 然后再想有没有第三种方法. 我想如果把拨号的任务交给这个硬路由, 然后DHCP和其他服务还是交给软路由做, 但是软路由只用一根网线接到主硬路由LAN上, 主硬路由的另一个LAN口还接AP2. 这样主硬路由的WAN就被利用上了, 接在了光猫上. 而这里多利用的一个口就会导致软路由上少用一个口, 软路由以前的WAN口现在是空闲的, 成了一个单臂路由. 但是因为软路由是openwrt系统, 他的WAN和LAN可以在软件上定义, 我可以把剩下这个WAN改成LAN, 这样就多了一个可以利用的LAN口了. 我们家最大带机量应该是10个左右, 我感觉这对硬路由来说应该问题不大. 唯一的缺点就是这样在千兆链路上最大只能跑500Mbps, 不过这对我们家够了. 然后遇到一个离谱的问题, 搭好结构后, 本来就挺完美的, 就是感觉好像上网稍微有点慢, 就没注意. 过了一会QQ电话打不了, 上国内网站贼慢, 再过一会直接qq发不了消息, 但是可以收消息, 国内网站也上不了. 找了一圈, 把下面这俩拒绝改成了接受就没事了, 现在也不知道是为什么. 加入了xsh的zerotier网络, 在他失去了屏幕的游戏本上开了虚拟机, 渲染了一张图.","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"计算机网络 组网","slug":"计算机网络-组网","permalink":"https://orangecheers.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BB%84%E7%BD%91/"}]},{"title":"Softmax实现MNIST手写数字识别及推导","slug":"softmax-mnist","date":"2021-07-15T14:56:45.000Z","updated":"2021-07-15T16:44:41.000Z","comments":true,"path":"2021/07/15/softmax-mnist/","link":"","permalink":"https://orangecheers.top/2021/07/15/softmax-mnist/","excerpt":"求了两下午导, 调了半天代码, 终于验证了我寒假的想法, 自己用softmax回归(我也不知道这个叫什么)实现了MNIST手写数字识别.","text":"求了两下午导, 调了半天代码, 终于验证了我寒假的想法, 自己用softmax回归(我也不知道这个叫什么)实现了MNIST手写数字识别. 寒假里那篇讲Logistic回归的最后, 我按照Logistic回归的想法提出了一种解决多分类问题的方法, 然后想着这玩意不就能识别手写数字了嘛, 但是这学期一直在摸鱼, 没有去尝试写过. Logistic回归其实还是建立在线性回归上. 线性回归就是拟合出一个矩阵 W , 让 H=Wx 尽可能逼近真实答案. Logistic回归是加了一个非线性函数Sigmoid函数. 他构造的是 H=S(Wx), 把输出定义为属于其中一类的概率, 让 H 尽可能逼近真实答案. 因为Sigmoid函数是可导的, 所以就可以利用链式法则求出 H 对矩阵中每一项的导数, 即 \\frac{\\partial H}{\\partial W_i}. 这样就可以找到这个函数在一个点的梯度, 就可以用梯度下降啦. 而在这个基础上, 我们可以让 H 不再代表一个数, 让他表示一个 N \\times 1 的矩阵, 其中 N 是类别个数, 每一项代表输入处于这一类的概率. 然后还是利用一个可导函数+线性拟合的思路, 让 H = F(Wx), 这个函数 F 需要根据线性拟合的结果(也是一个 N \\times 1 的矩阵), 得到这个输入属于每个类的概率. 这个函数首先要保证输出的矩阵每一项加起来为1, 因为输入处于每一类的概率之和一定为1. 还要保证这个函数的输入(即 Wx )越大, 对应的概率也要越大. 我当时提出直接用输入的每一项比上和, 即\\frac{A_i}{\\sum _j A_j} 来当作这个输入函数. 但是发现还有个叫softmax的东西, 就直接用了softmax, 有时间试试我提出的那个咋样, 肯定不好用, 我就想知道有多不好用. softmax看名字就知道这是一个soft的max. 为了满足输入越大概率越大, 我们可以直接用一个max函数. 即对于一个 Wx , 直接看哪一项最大就行, 最大的就认为是分类的结果. 但是这样做有两个问题, 一个是直接这样把其他的可能性一棒子打死, 就不给他们翻身的机会. 训练过程中是要不断修改的, 直接认为这次分类的结果是对的, 其他类别都是错的, 就没有了训练的空间. 第二个大问题就是, 这个函数不可导, 也基本没有了训练的方法. 所以softmax就来了: \\sigma(A)_i = \\frac{e^{A_i}}{\\sum_j e^{A_j}} 其实就是先把所有的值来个exp, 然后再用我的那个方法. 这样不仅保证值大的项得到的概率也很大, 而且还能和其他项拉开差距. 最重要的是, 它可导. 那对于手写数字识别这个问题, 我们就可以让P = \\sigma(Wx), 然后训练就行啦. P 就是我预测的这个输入在每一类的概率 然后选Loss函数, 和Logistic回归一样, Loss函数我们选用交叉熵, 交叉熵也在之前的文章讲过啦. Loss函数: J(W) = -\\frac{1}{N} \\sum^N \\sum ^{class} _i y_i \\ln P_i(x) 其中N是训练数据的个数, 第二个求和实际上就是求真实数据分布对我的预测分布的交叉熵. y_i 是真实分布的One-hot向量, 即真实在哪一类, 这个向量的哪一项就是1, 其他都是0. 在MNIST手写数字识别里, W 矩阵是 10 \\times 784 的, y 和 P 都是 10 \\times 1 的, x 是一个 784 \\times 1 的列向量. 其实, y 矩阵只有一项是 1 , 那就可以把交叉熵改成: J(W) = -\\frac{1}{N} \\sum^N \\ln P_y(x) y 是这个数据真实类别. 然后, 为了拟合出 P 里的 W, 需要求出 J(W) 对 W 的每一项的偏导, 即\\frac{\\partial J(W)}{\\partial W_{ij}}. 由链式法则: \\frac{\\partial J(W)}{\\partial W_{ij}} = -\\frac{1}{N}\\sum^N \\frac{1}{P_y(x)} \\frac{\\partial P_y(x)}{\\partial W_{ij}} 下面研究 P 对 W_{ij} 的偏导. \\frac{\\partial P_k(X)}{\\partial W_{ij}} = \\sum _t\\frac{\\partial P_k(x)}{\\partial A_t} \\cdot \\frac{\\partial A_t}{\\partial W_{ij}} 考虑到当 t \\neq i 时, \\frac{\\partial A_t}{\\partial W_{ij}} = 0, 所以: \\frac{\\partial P_k(X)}{\\partial W_{ij}} = \\sum _t\\frac{\\partial P_k(x)}{\\partial A_t} \\cdot \\frac{\\partial A_t}{\\partial W_{ij}} = \\frac{\\partial P_k(x)}{\\partial A_i} \\cdot \\frac{\\partial A_i}{\\partial W_{ij}} 其中, P_k(x) = \\frac{e^{A_k}}{\\sum_j e^{A_j}} A = Wx A 是一个 10 \\times 1 的列向量. 由矩阵相乘可知, \\frac{\\partial A_i}{\\partial W_{ij}} = x_j 所以主要看\\frac{\\partial P_k(x)}{\\partial A_i} 就行啦. 要求\\frac{\\partial P_k(x)}{\\partial A_i}, 首先要讨论一下 k 和 i 的关系. k = i 时: \\frac{\\partial P_k(x)}{\\partial A_k} \\cdot \\frac{\\partial A_k}{\\partial W_{kj}} = \\frac{e^{A_k} \\cdot (\\sum_j e^{A_j}) - e^{A_k} \\cdot e^{A_k}}{(\\sum_j e^{A_j}) ^2} \\cdot x_j\\\\ = \\left[ \\frac{e^{A_k}}{\\sum_j e^{A_j}} - \\left(\\frac{e^{A_k}}{\\sum_j e^{A_j}}\\right) ^ 2\\right] \\cdot x_j \\\\ =\\left[ P_k(x) - P^2(x)\\right] \\cdot x_j k \\neq i 时: \\frac{\\partial P_k(x)}{\\partial A_k} \\cdot \\frac{\\partial A_k}{\\partial W_{kj}} = -\\frac{e^{A_k}}{(\\sum_j e^{A_j}) ^2} \\cdot e^{A_i} \\cdot x_j \\\\ = -P_k(x) \\cdot P_i(x) \\cdot x_j 然后把玩意带回到\\frac{\\partial J(W)}{\\partial W_{ij}} = -\\frac{1}{N}\\sum^N \\frac{1}{P_y(x)} \\frac{\\partial P_y(x)}{\\partial W_{ij}} 里. \\frac{\\partial J(W)}{\\partial W_{ij}} = \\frac{1}{N} \\sum ^N \\left[ P_y(x) - 1\\right] x_j\\space when \\space(i = y) \\\\ \\frac{\\partial J(W)}{\\partial W_{ij}} = \\frac{1}{N} \\sum ^N P_i(x) x_j \\space when \\space(i \\neq y) 最后求出来的结果还是很简单的. 公式推到完啦, 下一步就是写代码. MNIST数据集谷歌一下就有了: 下下来之后是个二进制文件, 下面介绍了二进制文件的构造. 这是训练集输入, 从第16B开始, 每一个字节代表一个像素, 一张图有784个像素, 一共有60000个图. 这是训练集输出, 从第8B开始, 每一个字节代表一张图片的标签. 为了验证一下数据是不是这样用的, 我写了个程序把第一个图片搞出来看看长啥样. 把这个输入文件从第16B开始, 读取784B, 生成到一个ppm图片里. 我猜这是个5. 然后按照输出的格式, 读取第8个字节. 果然是个5, 我眼真好使. 除了训练数据, 他还给了测试数据, 只不过测试数据只有10000个. 验证了这些数据集的构造后, 就开始写代码. 第一部分就是读入数据集嘛, 构造一个784 \\times 60000 的训练输入矩阵. 但是我无论用什么方法, 读入数据都挺慢的. 后来我发现numpy里有个叫fromfile的东西, 可以直接读取这种东西, 速度飞快, 大意了. 然后就是把上面的推导过程写成代码, 代码挺难写的, 而且要注意输入从一个数据变成了60000个数据同时输入, 写了一两小时才写完. import numpy as np m = 60000 n = 10000 trainx = np.fromfile(open(\"train-images.idx3-ubyte\"), dtype=np.uint8)[16:].reshape((m, 28 * 28)).T rawtrainy = np.fromfile(open(\"train-labels.idx1-ubyte\"), dtype=np.uint8)[8:].reshape(m) testx = np.fromfile(open(\"t10k-images.idx3-ubyte\"), dtype=np.uint8)[16:].reshape((10000, 28 * 28)).T rawtesty = np.fromfile(open(\"t10k-labels.idx1-ubyte\"), dtype=np.uint8)[8:].reshape(10000) t = np.ones((10,784))/1000 def softmax(x, s): y = np.exp(x) for i in range(s): y[:,i] = y[:,i] / y[:,i].sum() return y def calcP(w): return softmax(np.dot(w, trainx),m) def calcPtest(w): return softmax(np.dot(w, testx),n) def calcJ(P): J = 0 for i in range(m): J = J + np.log(P[rawtrainy[i]][i]) return J / (-m) def calcJd(w): P = calcP(w) print(\"loss:\", calcJ(P)) for i in range(m): P[rawtrainy[i]][i] -= 1 tt = np.zeros((10,784)) for i in range(m): tt += np.dot(P[:,i].reshape((10,1)),trainx[:,i].T.reshape(1,784)) #print(trainx[:,1].T.reshape(1,784), P[:,1].reshape((10,1)), np.dot(P[:,1].reshape((10,1)),trainx[:,1].T.reshape(1,784))) return tt/(m) learning_rate = 0.000005 def gradient_descent(t): tt = t - learning_rate * calcJd(t) # print(tt) # print(t0,t1,calcJ(tt0,tt1)) return tt P = calcPtest(t) tcnt = 0 for i in range(n): if np.argmax(P[:,i]) == rawtesty[i]: tcnt = tcnt + 1 print(\"acc:\", tcnt/n) for i in range(10000): #print(t) t = gradient_descent(t) if i % 10 == 0: P = calcPtest(t) tcnt = 0 for j in range(n): if np.argmax(P[:,j]) == rawtesty[j]: tcnt = tcnt + 1 print(\"Epoch\",i,\"// acc:\", tcnt/n) 为了把训练结果表示的更清楚一些, 我每10次迭代都会用测试集测试一下正确率. 调试也调了挺长时间的, 包括调代码的错误, 调学习率之类的. 不过出人意料的是, 这玩意竟然只需要迭代一次就能达到67%的正确率. 当时刚跑出来正确结果我都不信, 因为调了半天, 我都觉得我这辈子调不出来了. 然后我在训练之前用随机的参数矩阵测试了一下正确率, 果然是10%左右, 就说明我的测试正确率的代码没问题, 他的正确率确实只用了一次迭代就达到了67%. 迭代20次时, 正确率已经达到了86%左右, 之后正确率上升的就慢慢缓慢了. 这么简单的方法能达到这么高的正确率是我没想到的, 不愧是机器学习的Hello World. 这个方法其实和一个全连接的神经网络是一样的, 只是我直接写成了矩阵形式. 不怎么参考别人, 自己推公式+自己写程序最后出结果挺快乐的, 感觉自己什么都会, 有点飘了. 下班了, 明天还要去讲课, 这几天好累. 感觉后面应该要学点东西了, 思而不学则殆.","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"MOMOPARK-赛格-宜家之旅","slug":"momopark-saga-ikea","date":"2021-07-13T17:08:05.000Z","updated":"2021-07-15T14:55:19.000Z","comments":true,"path":"2021/07/14/momopark-saga-ikea/","link":"","permalink":"https://orangecheers.top/2021/07/14/momopark-saga-ikea/","excerpt":"13号99就回家了，12号99要开一天团代会，所以11号就出来玩啦。","text":"13号99就回家了，12号99要开一天团代会，所以11号就出来玩啦。 本来上篇文章最后写了一点这些事情的，但是 今天送她的时候跟她梳理了一路，把那天的行程完整的理一遍了。 Day 0 前一天，本来是想去看电影的，找到了想看的电影之后去订票。发现都是空的，以为我们要包场，但是怎么都订不下来，就放弃了。 太晚了，当时只想到一个momopark可以去，因为有好喝的草莓长岛冰茶，然后去哪还不知道就睡了。 出发 早上九点多从丁香出发，先去图书馆超市买点东西，我买了一瓶热带风味和两个香肠。进超市的时候听到后面有很熟悉的声音，但是当时没注意。出门的时候99说刚刚孙江可带着他俩孩子在外面玩，还跟她打了招呼，我出来的时候他们已经走了。不过我就是见到他估计他也不认识我了，我只是一个平平无奇马原每节课都坐第二排的小透明。 99说他之前跟舍友打车去的时候，司机的导航不会念momopark，只会M-O-M-O-P-A-R-K这样念出来。 然后找了两辆小黄车，准备从北门骑出去骑到地铁站。但是失算了，北门门口的雷沣路在快到西太路上的部分有一个超大的大水坑，后面还都是车，趁着车停下来等红灯的时候我们俩蹭过去了。 路上回头看到了云和山, 超级好看, 但是99的相机一直在我那, 我今天还没带, 就被埋怨没带相机了, 我是罪人. 骑到国际医学，进6号线，到科技路转3号线，到吉祥村下车，就到momopark啦。 MOMOPARK 第一步先去买草莓长岛冰茶，99说她本来想要半糖，但是要成了无糖，但是我感觉还是挺甜的，可能是我的味觉有点问题。 然后去了无印良品，又看到了爆款透明笔盒和上次来就发现的瓶装咖啡。为了找点事干，99问我，“你要喝咖啡嘛”，我说我不。 出去的时候看到一个奇怪的店名，我叫它一撇一捺。应该也不是日语，长音符号也不会出现在开头。 看到了popmart的盲盒机。为了找点事干，99问我，“你要买盲盒嘛”。我们俩上去看一下，最低59，算了。 旁边有一家火炉旁烤肉，之前99陪我去医院的时候就在火炉旁烤肉吃的，但是当时是去四楼那家，比较大。这一家比较小，上次跟科科和王老师去北校区的时候来问过，说这一家只能坐两个人，三个人只能去四楼那家。 连续两次来momopark都吃的烤肉，而且这里除了烤肉也没太多好吃的东西，只能随便吃吃。然后99提议去问问杨神momopark有什么好吃的，当时我也没太纠结为什么要找杨神，反正就找了，杨神真万能。 然后去了乐高店，进去看到了一个打字机. 店员过来给我们介绍这个打字机是新品, 跟真的打字机一样的效果. 我小心嘀咕了一句\"这玩意可以打字嘛\", 然后99直接去问店员了. 店员看着我们, 沉默了几秒, 说这个是不能真的打出字的, 因为你想打字是要墨的, 这里面肯定没有墨. 我感觉他沉默的时候可能在想他面前这两个人是什么东西. (左下角打字机) 去了西西弗书店, 看了好长时间的书. 还找到一些很有格局的东西. 99看中了一个名著徽章, 但是问了店员才知道卖完了. 最后她去网上买了一个, 她刚走今天东西就到学校了, 我帮她拿了. 还不是很饿，就先上二楼逛了。刚上二楼有个那种传声筒，就是很多颜色的弯曲的管子，然后一个人站在一个管子的一边，另一个人站在另一边，就可以互相说话了。然后我们俩去试了一下，她先去听我去另一边拍了一下，然后我也想试试，我们俩就换了个位置，然后她拍我听。后来才想到为什么一定要换位置呢。最近的智商越来越不够用了。 对面有家Calvin Klein Jeans, 99也有他家的东西, 只不过是块表, 而这家店只卖牛仔裤. 然后接着去找点事干，三楼都是女装和童装, 我们努力想要融入这层, 但是还是不太行. “你要买高跟鞋嘛”，“你要买裙子嘛”，\"你要给你家亲戚小孩买衣服嘛\", \"你要买珠宝嘛\". 不过momopark有个好地方就是他里面挺多艺术品的. 这个叫婚变的作品, 里面有好多烧了的写满了字的纸. 我们研究了半天, 还是没看清纸上写的什么. 上楼进四层, 里面都是吃的, 而且基本都是烤肉和火锅之类的. 逛了一圈也没找到啥想吃的, 倒是99遇到了两个图灵同学, 我也不认识, 也不敢说话. 之后去B1找杨神说的牛肉dong饭, 都进去了, 看菜单, 发现不辣的都是带牛肉的, 不带牛肉的都是辣的, 99不吃牛肉也不吃辣, 就走了. 随便找了家卖面的, 里面只有biangbiang面和绿绿的菠菜面, 我们点了两份biangbiang面, 感觉还可以. 给我们的小票上写的是叫BB面, 挺神奇的. 吃完了去MINISO, 99想买个墨镜, 顺便看看有没有玉桂狗口罩. 进去虽然没有找到玉桂狗口罩, 但是找到了玉桂狗的浴垫和拖鞋. 我觉得把玉桂狗踩在脚下也太残忍了, 但是99说拖鞋是把玉桂狗放在脚面上, 其实还行, 我觉得这样一说好像也有点道理. 99试了几个墨镜, 前几个我都觉得太大了, 但她说她之前在福州丢的墨镜就这么大, 但是我还是觉得比例不是很协调. 最后换了几个我觉得还可以, 她就买了. 我还想找个帽子, 这几天去师大附中路上也太晒了, 但是没找到合适的. 临走的时候99试了几个香水, 我觉得那个海盐的挺好闻的, 比较清新, 还买了个iPhone 11的手机膜. momopark的艺术品有的还挺有感觉, 两个人又参观了一会, 去了赛格. 赛格 从三号线吉祥村上车, 坐一站就到小寨, 出站直接到赛格B2层. B2层一出地铁站有个奇怪的店, 99说刚刚在momopark是不是也有这个店, 但是我经典🐟的记忆, 没什么印象. 旁边是一家Zippo, \"你要买打火机嘛\", \"吹灭了可以召唤鬼怪\". 遇到一家毛绒玩具店, 里面的动物真的和真的一模一样, 特别像. 还有个小的猫, 包装袋上印着\"按压此处发出声音\", 99按了一下发现这个猫真的可以叫. B1层中间有个贼大的钻石💎形的建筑, 是周大福, 还挺好看的. 一楼全都是化妆品店, 99给我介绍了好多化妆品牌子, 不过大部分我都知道, 但是还是有很多没听说过. 二楼三楼全都是女装, 童装和鞋子, 和momopark的三楼差不多. 然后进了四楼一家匡威, 过来的导购和99穿的还是一样的鞋子, 逛了一圈就出来了, 感叹一下匡威的鞋越做越丑了. 五楼全都是电子产品店, 先去看了一家苹果, 体验了一下M1的MacBook和新的12.9的IPad Pro. 然后我用我的和他的比一下, 发现新的IPad Pro 12.9变厚了一点点, 可能是因为Mini-LED吧. 不过妙控键盘真的挺好用的, 就是有点贵. 然后去逛了京东之家, 外星人, 微软. 我们俩还都拿着上次去西交发的微软手提袋进去的, 不过没啥用, surface还是用着挺难受. 去了6楼, 但是都是吃的, 中午也吃过饭了, 就准备下楼. 太累了 , 所以选择去坐直梯. 在六楼没找到直梯, 就下到了五楼, 找到了直梯. 电梯在11楼, 一层一层下来, 大概到六七层电梯就满了, 五楼根本不停. 我以为他下一次会只到五楼来接我们, 但是发现我想多了, 他还是去11楼然后一层一层下来. 我们要去B2, 我们发现旁边有个只停偶数层的电梯, 正好可以去B2. 等了半天电梯还是不在这停, 我们以为电梯满了. 过了一会才想起来这是5楼, 人只停偶数层. 然后找了个只停奇数层的电梯, 但是到我们这还是满了, 我决定拉着她去走扶梯. 其实扶梯走起来还挺快, 一会就到地铁了. 地铁二号线小寨上车, 到北大街换一号线, 到皂河地铁站下车去宜家. 宜家 一号线不愧是一号线, 整体都比较破旧. 特别是皂河地铁站, 本来感觉这里的空调就不是很凉快, 出站上楼梯的时候觉得每上一个台阶气温都上升了1度. 不愧是西安, 一出站大太阳直接给我送走. 周围还不是很繁华的样子, 我很怀疑自己是不是走错了, 直到出站一群小三轮喊着\"来来来宜家宜家\"我才知道这地方是对的, 但是还要走一段. 地铁上还遇到了两个喝醉酒的, 我拉着99远离了他们, 离远点好. 从地铁站到宜家路上遇到了一个高楼, 玻璃外墙映着云和天空, 挺好看的. 宜家旁边这个商业中心叫搜宝中心, 这名字也很奇怪. 一进宜家我们俩就都闻到一股山核桃味, 不知道是什么东西让我们都觉得这是山核桃味, 可能就是山核桃, 虽然可能性不大. 宜家先从二楼逛, 第一个区域就是卖沙发的. 99说她好累, 找到了一个1299的沙发就坐了上去. 坐了大概十分钟, 我问她你还能动一动嘛, 她说能, 就换了个地方. 找了个2499的很orangecheers的沙发(橙色的)坐着, 然后我们把刚买的手机膜给她手机贴上了, 在宜家里贴膜可能也只有我们能干出来. 在沙发上看到一个小女孩, 她爸拿着一条玩具狗, 说\"我把这个买给你\". 99跟我说\"我要不要买个那个给你\", 然后她一看售价99大洋, 99瞬间没有了嚣张气焰. 然后把其他几乎所有沙发都体验了一遍, 发现沙发除了皮质的, 其他的沙发都是越贵越舒服. 但是皮质的沙发都很贵而且不是很舒服, 主要是比较有质感. 继续往后走, 有个展示用的55平的三人小屋, 我们去卧室里看了下, 是单独的隔间, 里面还有个大床. 我们在里面躺了一会才出来. 后面是办公区, 试了几个椅子, 感觉都不是很舒服. 99说她累了, 我抬头看一下指引牌, 给她指了一下说第7个就是卧室展间, 里面一定是很多床. 然后就直奔卧室了. 路上我看到了卖夹子的, 我买了两套夹子. 中间有展示用的相框, 99说这相框里的照片还没她拍的好看. 看到了有小车, 我就拉了一个, 把我们俩的伞和包都放进去了. 看到了好多台灯, 但是他们的开关都很隐蔽, 我们花了点时间把那些台灯的开关都找到啦. 卧室展间里的床都有提示, 说体验床垫不能用手压, 不能用膝盖压, 不能坐着压, 必须躺下感受. 他都这么说了, 那我们也必须要躺着了. 所以我们把所有的床都躺了一遍, 发现那个宣传什么云端体验的床垫还不错. 还有那种好硬的床垫, 说是什么加强弹簧, 反正我们都不是很喜欢. 躺下来的时候正好能看到屋顶上的一些奇奇怪怪的装饰. 都是用塑料纸挂起来的大波浪的感觉, 然后每次躺下99都会给我指哪里的大波浪有瑕疵, 掉下来了或者挂歪了, 逼死我这个强迫症. 在其他床躺下的人换了一拨又一波, 只有我们俩一直在一个床上躺着. 然后过来俩人看这个床, 估计是想买. 然后他俩本来是想无视我们, 都四目相对了也假装没看到. 最后我们受不了了, 爬起来了, 他们好像是觉得我们输了一样笑我们, 99还比了个手势, 请他们躺床上. 后面是儿童区. 看到了那种拆卸下来装一包的儿童小板凳, 四个板凳腿拆下来和保龄球的那个瓶子一样, 99觉得和胡萝卜一样, 反正就不像板凳腿. 有个可以让你试笔的地方, 99在上面写了代码, 也就是上个文章的题图. 看到了经典宜家大鲨鱼, 还有好多熊, 熊猫和蟒蛇. 99抱了半天才走. 那个狗熊真的不错, 抱着的时候头会搭在你的肩上, 他的头还好重, 肚子还好大, 反正就是舒服, 99说\"反馈感极强\". 然后去宜家餐厅吃饭, 吃饭的事上次那个理概念的文章里最后也讲了很多. 主要就是贵, 我拿了牛排和土豆泥, 土豆泥是肯定吃不完的, 我就没吃完过那玩意. 99去买两根烤肠, 我去旁边拿了个黄色大袋子, 把我们的东西都放了进去. 但是小车好像不让拉进去, 就放在了外面. 然后节选一段那个文章里对饮料的描述: \"还有饮料就离谱, 看出了个新口味, 什么越橘, 第一次去接了一杯是透明的, 我以为就这么高级, 结果发现这长的这么像水的东西喝起来居然也跟水一模一样. 过一会再去接一杯才知道这玩意应该是粉红色的酸不拉几的, 我合理推测我第一次接的时候是刚加了原料之类的, 还没搞好就被我接了. 临走的时候99说想喝无糖可乐, 然后我去接了一杯, 接出来了纯水密堆积无糖可乐填空隙的淡棕色的东西, 喝起来跟丁香食堂某些窗口刚开业的时候送的兑水可乐一个味, 接了几杯颜色就没变过, 就放弃了. 餐盘都送了才看到有人接出来了最起码像无糖可乐的东西, 血亏.\" -- Orange Cheers 《重新理解简单回归相关的一些概念》 99虽然不吃牛肉, 但是她想切牛排, 她就说我牛排切的不好, 拿着我的刀和叉切了去切了. 我说我也想切, 就让她给我留了一半. 吃完送完餐盘之后看到了好看的晚霞, 金光闪闪的, 就拍了下来, 就是文章首图. 99说, \"没有我你肯定看不到这么好看的晚霞\". 回去快到地铁站了才发现这照片下面还有跳广场舞的. 吃完出来, 我推了个大推车, 这玩意真的重还难推. 99在前面拉着控制方向, 我在后面推着才勉强控制住. 下楼, 99想吃宜家经典2块钱的冰淇淋, 但是不知道在哪, 就去问了工作人员, 工作人员说在收银之后. 下楼还有一段可以逛, 周围好多毛绒玩具放在奇奇怪怪的地方, 特别是那个蟒蛇, 哪里都有它. 99发现那个蟒蛇本来就有形状的, 怪不得我刚刚想把它缠脖子上不好缠. 99抱了一个大鲨鱼, 一直抱到收银台都不舍得放下来. 结账, 去买冰淇淋. 我就要了个2块钱的香草+巧克力的双色冰淇淋, 她要了个3块的草莓雪芭, 但她说好酸. 到皂河地铁站, 坐地铁回去啦. 路上看到新年快乐, 跟我在师大附中看到\"你好十月\"一样的穿越感. 本来准备1号线到北大街转2号线, 再到小寨转3号线, 再到科技路转6号线的. 在一号线上我灵机一动多坐了一段直接到通化门转3号线, 这样就少换乘了一次, 也不知道哪个更快.但是换乘确实少了一次, 99都在地铁上睡着啦. 到了国际医学中心, 我说我渴, 我们俩就去自动售货机上买了两瓶水溶C100, 都给酸死啦. 从国际医学到学校走回去的, 路上聊了好多, 如果不是她我这学期连一次都不会出来玩的吧, 好幸运啊.","categories":[{"name":"游记","slug":"游记","permalink":"https://orangecheers.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"重新理解简单回归相关的一些概念","slug":"regression-concept","date":"2021-07-10T14:46:37.000Z","updated":"2021-07-13T17:14:25.000Z","comments":true,"path":"2021/07/10/regression-concept/","link":"","permalink":"https://orangecheers.top/2021/07/10/regression-concept/","excerpt":"这两天准备手写一个手写数字识别, 但是在推导公式的时候感觉还是有点费劲, 可能是对之前的那些概念理解不是很深. 先去研究一下一些概念的本质含义吧.","text":"这两天准备手写一个手写数字识别, 但是在推导公式的时候感觉还是有点费劲, 可能是对之前的那些概念理解不是很深. 先去研究一下一些概念的本质含义吧. Loss函数? 首先我遇到的直接问题就是怎么写多分类的loss, 研究一下Logistic二分类中是使用的交叉熵来定义的Loss. 这个可能可以从两个方向去理解. 第一个方向是交叉熵是什么, 第二个方向就像我之前文章里说的那样, 交叉熵是二分类问题中的似然函数. 相对熵(KL散度) 相对熵或KL散度是衡量两个分布差异的一个量. 相对熵的定义是, 站在A的角度看, B与A概率对数差的期望. 用数学公式表达是: D_{KL}(A||B) = -\\sum_i P(A_i) \\ln\\frac{P(B_i)}{P(A_i)} 站在A的角度看的意思是, 某个概率对数差发生的概率是对应A取该值的概率. 重要的是, 相对熵并不满足对称性, 也就是说站在B角度看和站在A角度看得到的结果是不一样的. 站在B角度看的相对熵: D_{KL}(B||A) = -\\sum P(B_i) \\ln\\frac{P(A_i)}{P(B_i)} 也就是说, D_{KL}(A||B) \\neq D_{KL}(B||A). 交叉熵 把上面A角度下的相对熵公式进行变形: D_{KL}(A||B) = \\sum_i P(A_i)\\ln P(A_i) - \\sum_iP(A_i)\\ln P(B_i) 可以惊奇地发现, 第一项就是A的熵, 如果A的分布不变, 那他就是个常数. 我们把后一项拿下来, 当作A对B的交叉熵. 注意一下, 自己最自己的交叉熵其实就是自己的熵, 并不一定是0. 分布 这个概念也挺重要, 虽然很基本. 高中学的分布列其实就是把一个随机变量所有可能取值对应的概率列出来. 一个随机变量在每一个值上不同的概率分布情况. 在训练的过程中, 其实出现了两个分布. 一个是正确的分布, 就是训练集的标签, 在二分类问题中, 这个是一个在一类的概率为1, 另一类概率为0的一个分布, 随机变量两种取值(在第一类和在第二类). 在多分类问题中, 这个实际上是一个在一个类的概率为1, 其他类的概率都为0的一个分布. 另一个分布是模型预测出的分布, 他对于输入, 给出这个输入在每一类他认为的概率. 我们的目标就是让这两个分布(预测出的分布和实际分布)差异尽量小. 实际分布是不变的, 所以我们取实际分布对预测分布的交叉熵. 为了让这两个分布差异尽量小, 我们需要让交叉熵尽量小. 所以我们用交叉熵当作Loss函数, 然后最小化Loss函数. 这就是第一种理解方法. 第二种理解方法是纯数学上的. 似然 似然函数也是一种条件概率, 但是他考虑的因果关系是相反的. 正常我们考虑一个分类问题, 是求在给定的参数下, 这个输入属于哪一类的分布. 但是似然函数研究的是, 现在知道这个输入属于哪一类, 要求这个参数取值的相关信息. 这就很有贝叶斯公式的味道. 但是似然函数研究的并不是概率. 似然性/极大似然估计 似然函数终究还没有考虑现在的自变量是参数, 他写出的还是这个事件发生的概率和参数的关系, 我们只是人为地把自变量换成了参数. 所以似然函数得到的并不是\"参数取这个值的可能性\", 而\"参数取这个值的时候, 这个事件发生的可能性\". 这个和概率是很不一样的. 首先, 在给定参数下, 对于一个随机变量X, 他所有取值的概率加起来一定是1. 但是对于参数的每个取值, 这些似然函数得到的值加起来并不一定为1. 我们把这个似然函数得到的值叫做似然性. 直接看似然性的取值是没有任何意义的, 只有两个同一问题下的似然性在一起比较的时候, 似然性更大的那个参数取值才被我们认为是参数更有可能取到的值. 所以, 我们可以找到似然性最大的参数取值, 并认为他就是参数的最可能取值, 这就叫极大似然估计. 实际上, 交叉熵就是多分类问题的似然函数加个负号., 在之前说Logistic回归的时候, 已经证明了在二分类问题中的交叉熵就是似然函数加负号(好像只是放个了草稿). 为了做极大似然估计, 我们需要最小化交叉熵, 这是另一种理解交叉熵的方法. 本来准备11号把这个文章理完的, 但是11号出去玩了一天, 上午去momopark中午去赛格下午去宜家, 宜家真是好地方, 把里面最贵的沙发和床都体验了一遍. 就是一号线好像都不是很新的样子, 从皂河地铁站出来每上一个台阶感觉周围的气温都上升了1度, 一出门看一群三轮车喊宜家宜家我才确认自己来对了地方. 饭也有点贵, 随便吃个牛排啥的就四五十了, 不过土豆泥还是一如既往的吃不完, 我就从来没吃完过宜家的土豆泥. 还有饮料就离谱, 看出了个新口味, 什么越橘, 第一次去接了一杯是透明的, 我以为就这么高级, 结果发现这长的这么像水的东西喝起来居然也跟水一模一样. 过一会再去接一杯才知道这玩意应该是粉红色的酸不拉几的, 我合理推测我第一次接的时候是刚加了原料之类的, 还没搞好就被我接了. 临走的时候99说想喝无糖可乐, 然后我去接了一杯, 接出来了纯水密堆积无糖可乐填空隙的淡棕色的东西, 喝起来跟丁香食堂某些窗口刚开业的时候送的兑水可乐一个味, 接了几杯颜色就没变过, 就放弃了. 餐盘都送了才看到有人接出来了最起码像无糖可乐的东西, 血亏. 这两天还在尝试自己手推多分类问题的过程, 明天上午送99去北站, 下午去师大附中讲课, 争取地铁上推完晚上就写.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"计算机网络期末预习笔记3-传输层","slug":"Chapter23-24","date":"2021-07-10T08:18:00.000Z","updated":"2021-07-10T08:34:29.000Z","comments":true,"path":"2021/07/10/Chapter23-24/","link":"","permalink":"https://orangecheers.top/2021/07/10/Chapter23-24/","excerpt":"","text":"现在是6月22日下午15:38, 学不完了 期末速成计网这种层次感分明的东西有种爬天梯的感觉. Chapter 23/24 UDP,TCP和SCTP/拥塞控制和服务质量 传输层概述(自己编的): 传输层提供的是端到端的逻辑通信, 一台主机上的所有进程复用同一个IP层. 数据到了传输层, 就会被分用到不同的应用程序上. 传输层所有功能: 应用进程的逻辑通信 差错检测 无连接或者面向连接的服务 无连接 面向连接 连接管理(三次握手) 流量控制/拥塞控制 复用/分用 我们经常说传输层是可靠的, 但是传输层的UDP并不提供可靠性, 所以说传输层是可靠的是面对TCP来说的. 实际上每一层都有可靠和不可靠的协议, 单独直接说某一层可靠或者不可靠是笼统的. 例如在几十年前人们都说链路层就已经是可靠的了, 是因为那时候链路层普遍使用了HDLC协议. 现在由于网络质量改善, 链路层普遍使用了不可靠的PPP协议, 我们又说链路层是不可靠的了. 同样, 有无连接也是这样的, 现在我们说网络层无连接, TCP才提供了连接, 是因为IP协议是无连接的, 之前的X.25之类有连接的网络层协议被淘汰了而已. 马上就要考试了这么多没学我还在这写这些东西, 迟早要挂. 熟知的端口号 常识 FTP: 20(数据),21(控制) Telnet: 23 SMTP: 25 DNS: 53 TFTP: 69 HTTP: 80 SNMP: 161 套接字 套接字就是IP+端口号. UDP 常识就不多说了. UDP校验 UDP的头只记录了源端口, 目的端口, 和数据的长度(包括头部). 在检验的时候, 需要加一个12B的伪头部一起校验, 但是这终究还是个伪头部, 不会被发出去. 伪头部里包含了源IP和目的IP, 还有一些奇怪的东西. 校验就是把从首部到数据结束的所有东西两个字节两个字节加在一起, 如果数据不是偶数就要补一个0字节. 注意, 校验过程中遇到的校验位按照0算. 算出来一个2B的东西, 取反就是校验位. 验证的时候把校验位和所有东西加在一起, 如果结果是全1, 就说明数据没大问题. TCP 段格式 我服了, 这nm全要背. 懒得解释了 懒得解释了 序号, 就是Seq, 现在要发的第一个字节的编号. 注意TCP是给字节编号, 所以如果这个TCP发了100B数据, Seq=701, 下一个TCP的Seq=801 确认号, 字节编号, 是累积确认, 是期望得到的下一个字节的编号. 数据偏移, 其实就是头部的长度, 跟IP首部长度一样, 单位是4B. 注意这个跟IP分段的那个数据偏移不一样. 保留字段, 现在没用. 紧急URG, 表示这个TCP包比较急, 从开始到紧急指针指向的地方这部分数据不进缓冲区直接发出去吧, 剩下的数据还是要进缓冲区的. 确认ACK, ACK=1的时候确认号才有用. 一旦TCP建立了, ACK必须都要为1. 推送PSH, 这个数据也急, 但是不完全急, 要进缓冲区, 但是进了缓冲区就赶紧交付给上层, 不要等缓冲区满了再交付. 复位RST, RST=1的时候, 表示出了大问题, 要把TCP断掉重连. 同步SYN, 建立连接用的. 终止FIN, 终止连接标志. 窗口字段, 表示接收方现在还有多少接收缓存. 校验和, 和UDP一样, 计算的时候要加假头(假头的内容和UDP有一个东西不一样, 要把17改成6) 紧急指针, 就是开始到这里的数据都是紧急数据, 在URG里面提到过. 选项字段, 长度可变. 填充字段, 要把整个首部填成4B的整数倍. TCP连接建立 经典三次握手. 发送方发, SYN = 1, Seq = x. 这时不能带数据. 服务器发, SYN = 1, Seq = y, ACK = x+1. 这时也不能带数据. 发送方发, SYN = 0, Seq = x+1, ACK = y+1. 可以带数据发了. 只有最后一个段能带数据发, 但是所有的段都占用了编号 TCP连接拆除 经典四次挥手. 要关闭连接的一方A发, FIN = 1, Seq = u. B发, ACK = u+1, Seq = v. 这时候B有可能还有数据要发, B会接着发, A这时候也要接着收, 但是A不会再发东西了. B数据发完了, 发FIN=1, Seq = w, ACK = u+1. B到了LAST-ACK. A发, ACK = w+1, Seq = u+1. FIN只有第一次和第三次为1 TCP可靠传输机制 序号 TCP每次建立连接的时候, 都要选择一个不同的初始序号. 重传 首先, 发送方会动态估计RTT. RTT = (1-\\alpha)\\times 旧RTT + \\alpha \\times 新RTT旧新 然后, 超时重传时间RTO = \\beta \\times RTT 这个方法只有在TCP有用, UDP没有重传, 所以不需要. 即使链路层是完美的, 这些可靠传输机制也是必要的. 数据报可能会因经过的路由不同而失序, 或者路由错误计算导致TTL减到0, 或者中间某个路由器缓存炸了. TCP流量控制 滑动窗口 发送方和接收方都维护了一个滑动窗口, 长度在连接过程中会协商. 这个窗口和之前ARQ的窗口差不多, 注意就是发送方和接收方的窗口大小都是不固定的. 而且TCP的序号没有限制, 所以不会出现特别奇怪的问题. 超时 TCP为每个发送的报文段设置单独的计时器, 计时器超过RTO的时还没收到ACK就会重发. 快速重传 如果发送方连续接收到三次同一个ACK, 就知道那个数据肯定出事了, 就会直接重传那一个. 不用等到超时. 零窗口 接收方返回的ACK里面包含了接收方的缓存还有多大, 如果接收方不想收了, 或者收不了了, 可以返回一个带有rwnd=0的ACK, 这样发送方就会暂停发送. 等到接收方想收了, 它可以再发一个东西通知他继续发. 并且发送方还会每隔一段时间发一个试探性的包来询问接收窗口. TCP拥塞控制 流量控制只是两端的问题, 格局小了. 拥塞控制是为了整个网络着想, 格局很大. rwnd和cwnd rwnd是接收端窗口, 与接收端缓存大小有关. cwnd是拥塞窗口, 与发送方对网络情况的估计有关. 发送端真正的窗口大小应该是两个窗口的最小值. 慢启动算法 在刚开始, 发送方将cwnd设为1, 就是一个MSS的大小. 然后每次收到一个ACK之后, cwnd都会+1. 这样看起来增长的很慢, 实际上cwnd+1之后, 每次发送的数据也会变多, 收到的ACK也会变多, 所以cwnd实际上是指数级增长的. 拥塞避免算法 为了阻止cwnd指数增长, 在TCP开始之前, 需要一个慢启动门限ssthresh. 在cwnd小于等于ssthresh时, 使用慢启动算法; (指数增长) cwnd大于ssthresh时, cwnd每过一个RTT就会+1. (线性增长) 无论在什么时候, 只要出现网络堵塞的情况(就是ACK超时没发过来), ssthresh就会变成拥塞窗口的一半(但是不能小于2)(乘法减小), cwnd从1开始重新来. 快速重传算法 上面讲过了. 快速恢复算法 发送端连续收到三个连续相同确认后, 就执行乘法减小, 把门限减少为原来的一半. 但是新的cwnd不是改成1, 而是改成新的门限.","categories":[{"name":"笔记","slug":"笔记","permalink":"https://orangecheers.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://orangecheers.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络期末预习笔记2-网络层","slug":"Chapter19-22","date":"2021-07-10T08:16:00.000Z","updated":"2021-07-10T08:34:22.000Z","comments":true,"path":"2021/07/10/Chapter19-22/","link":"","permalink":"https://orangecheers.top/2021/07/10/Chapter19-22/","excerpt":"","text":"Chapter 19 逻辑寻址 哈哈, 全加粗了. IPv4地址 常识性的东西就不说了. 地址分类 ABCDE五类地址 重点在ABC类上. A类地址 A类地址网络号只有前8位, 其中第一位必须是0. 网络号全0表示本网络, 是预留的. 网络号后七位全1用于本地环回测试, 也是预留的. 所以A类地址有 2^{7} - 2 个网络 主机号是后面24位. 主机号全0表示网络号指定的该网络, 预留. 主机号全1表示广播, 预留. 所以A类地址一个网络最多有 2^{24} - 2 个主机 B类地址 网络号有前面16位, 其中前两位必须是10. 网络号128.0是不指派, 最少也得是128.1 所以B类地址有 2^{14} - 1 个网络 类似的, B类地址一个网络最多有 2^{16} - 2 个主机 C类地址 与B类地址类似: C类地址有 2^{21}-1 个网络, 最多2^{8}-1 个主机 几类特殊的地址 网络地址 就是主机号全为0, 只能用来标识网络, 不能分配给主机 直接广播地址 网络号+全1的主机号, 只能用来当目的地址, 在这个网络上的所有设备都将接受处理. 受限广播地址 就是255.255.255.255, 只能当目的地址. 这个网络的所有设备都要收. 不是整个英特网, 路由器会屏蔽这个包. 是一个E类地址 这个网络中的这个主机 就是0.0.0.0, 在主机第一次加入网络的时候问ip用. 是一个A类地址 这个网络的特定主机 就是网络号全0+主机号 是一个A类地址 环回地址 网络号是127, 主机号随意. 是一个A类地址 NAT NAT可以解决ip地址不够用的问题. 其实就是一个NAT服务器后面罩着一群小东西, 小东西用一个端口发的数据包到了NAT服务器就变成了NAT的另一个端口发的. 然后NAT服务器会记录下来这个对应关系, 收到对应的数据包再按照NAT表发回去. 如果从外面收到NAT表里面没有的数据包, 那就把他给扔了. 子网划分 子网 网络号+主机号不合理, 借用主机号的几位区别子网. 划分子网纯属网络单位内部的事情, 在外面看他还是一个网络. 子网掩码 子网掩码标识网络地址. 子网掩码与IP地址按位与结果就是他的网络地址, 只有子网掩码按位与之后相等的两个IP地址, 才在一个子网里. 划分子网的方法 直接按类 ABC类+子网划分, 不太好吧 CIDR 无分类编址. 就是没有ABC类之分, 一切都靠子网掩码. IP地址化成两部分: 网络前缀; 主机号 用斜线记法: ip地址/掩码1的长度 就是前多少位是前缀, 掩码长度就多少 路由聚合/超网 就是几个前几位相同的地址块, 可以合在一起用一个CIDR地址块包含起来, 就是看最长公共前缀. IPv6地址 128位, 16字节, 32个数, 8段. 缩短 每段开头有连续的0, 可以省去, 但是一段至少有一位. 如果有连续的全0段, 可以用一个**::**表示. 但是一个地址里最多只能出现一个**::** Chapter 20 IP协议 IP数据包的格式 一个一个说 版本: 4bits, 说明IP数据报用的IPv4还是v6 首部长度: 4bits, ipv4数据报首部最大60字节, 一般都是20字节, 这个0-15的数字*4就是字节数. 单位是4字节 服务类型: 8bits, 没人用过. 总长度: 就是包括头部的, 整个IP数据报的长度, 最长65535B(具体多长限制于MTU) 单位是1字节 标识: 是一个计数器, 用来产生数据包的标识 标志: 前两位是MF/DF, 第三位没人用, 分片用的. 片漂移: 分片用的 单位是8字节 生存时间(TTL): 到一个路由器就-1, 为0就给他扔了, 防止他转圈. 协议: 标明这个数据报应该交给什么协议处理. 首部校验和: 用一个更简单的方式, 只检查首部是否有错. 源地址 目的地址 分段 MTU Maximum Transmission Unit, 链路层的一个属性. 就是一个帧里面他能装的最大数据字节数, 不包括链路层的头. 也就是说一个IP数据报长度不能超过他的下层链路层的MTU. 以太网的MTU是1500 所以数据一大肯定是要分段的 标志位MF More Frames: 指示后面是不是还有这一帧被分出来的续帧. 也就是一个长达14800B的数据被做成了ip数据报, 长度15020, MF=0; 但是中间遇到了以太网, 看门的路由器就会把他分成10段, 每段1480B, 加上头正好1500B. 这十个数据报里面, 前九个的MF都是1, 只有最后的MF=0; IPv6数据报格式 好, 除了版本都不一样. 拓展首部是算在载荷里的. 版本: 4bits, 就是v4或者v6 通信量类, 8bits, 是一种优先级. 优先级中有两类, 前8个优先级可以被拥塞控制, 后8个不能被拥塞控制. 流标号, 20bits, 好像有一些神奇的用途, 视频和语音的传输之类的. 有效载荷长度: 16bits, 拓展首部+数据的长度, 最长能表示64KB. 下一个首部, 8bits, 协议字段或者类似链表指向下一个可选字段 跳数限制, 8bits, 类似TTL 源地址, 128bits. 目的地址, 128bits. IPv4和IPv6混合 三种技术: 双协议栈 头部转换 隧道 Chapter 21 地址映射 差错报告 多播 ARP 作用 一个主机在给另一个主机发IP数据报, 他知道对面的IP, 做好了IP数据报. 问题是链路层需要知道他的MAC地址. 这就是ARP的作用, 用一个IP就能拿到对应的MAC地址. 方法 就是这个主机先广播一个ARP数据报, 说明自己想要谁的MAC地址. 然后这个主机收到之后, 就会单播一个ARP数据报, 告诉他自己的MAC地址. 如果要发送给的主机和自己不在一个子网, 发送方就先找路由器的MAC地址. 数据报格式 硬件类型, 以太网都是1. 协议类型, IP协议都是0800H 硬件地址长度, MAC地址都是6 协议(地址)长度, IPv4都是4 操作类型, 请求是1, 回复是2 请求的时候, 目标MAC地址全0 封装 ARP是三层协议, 还是要经过链路层的封装. 封装的时候, 发送时目的MAC地址是广播地址, 全1. DHCP 好像不太考, 只要知道他分ip的就行了 ICMP ICMP报文有两种: 差错报告报文 询问报文 差错报告报文 终点不可达: 路由器或者主机不能交付数据报. 源站抑制: 拥塞而丢弃数据报. 时间超过: TTL为0, 或者终点在规定时间内不能收到数据报的全部报片. 参数问题: 数据报首部有不正确的值. (现在一般不发了) 改变路由: 仅由路由器发送, 让主机知道下一次应该发给其他路由(更好的路由). 不应发送差错报告报文的情况 对ICMP差错报文不应再发一次. 对不是第一个的分片数据报不发 对具有组播地址的数据报不发 特殊地址(127.0.0.0或者0.0.0.0)不发 询问报文 我感觉这个分类不重要 差错报文格式 ICMP虽然是网络层协议, 但是ICMP报文还是要当成IP数据报的内容, 前面加个IP头送给链路层. ICMP的差错报文包括了ICMP头, 还有出错了的数据报的IP头, 和那个IP数据报的数据的前8字节(包括了传输层的端口号) 所以ICMP封装好的报文实际上有两个IP头, 一个是他应该有的IP头, 还有出错了的IP头 IGMP 好像不太重要. 控制网络中加入离开之类的东西. 跟ICMP一样, 装在IP数据报里发出去. IGMP的IP数据报的TTL一定为1. Chapter 22 传递,转发和路由选择 传递和转发和路由选择的区别 传递是指知道了从哪发向哪之后, 把数据传过去的物理过程. 转发是指路由器根据转发表在决定从哪发向哪的过程. 路由选择是根据路由选择算法得到路由表的过程, 转发表是从路由表得到的. 在讨论路由选择的原理的时候, 不区分路由表和转发表, 都叫路由表. 路由表只给出下一跳的地址, 这样可以让路由表更灵活. 路由协议 自治系统: 就是比一个局域网更大的一个单位, 可以是一个机构的全部网络这样的, 这里面使用相同的路由选择协议. 路由协议分为两类: 内部网关协议, 在一个自治系统内使用的协议 RIP OSPF 外部网关协议, 组织不同的自治系统的协议 BGP RIP 使用距离-向量算法. 每个路由器每隔一段时间就把自己的路由表发给相邻的路由器. 一个路由器收到其他路由器的路由表后, 先把这个路由表的下一跳全部改成发给他路由表的这个路由器, 然后跳数全部+1. 然后把这个修改后的路由表跟自己的路由表比对, 发现改过的路由表有自己路由表没有的子网, 就把这一项加进去, 下一跳就走他. 发现他记录的哪一个地方自己的路由表也有, 看看自己本来是不是走他的. 如果本来就走他, 那无论如何都要更新一下, 变成他的距离+1. 如果自己本来不是走他的, 就看一下走他是不是会更近, 是的话更新一下. 每一段时间所有路由器都要跟最近的路由器沟通一下路由表, 如果有个路由器半天不说话, 旁边的路由器就知道他死了, 把距离改成16(不可达). 如果有个网死了, 旁边最近的一个路由器会在发自己的路由表的时候告诉旁边的人这个网死了, 其他路由器都会更新自己的路由表知道这个网死了. 但是可能会出现这样的情况, 就是有个网死了, 这个路由器刚想告诉别人这个网死了, 结果旁边有个傻逼嘴快发路由表告诉他自己可以到这个网, 只需要4步. 但是这个路由器可不知道这四步第一步就是从他那走. 然后这个路由器就听信这个傻逼把自己的路由表也给改了. 过了一会这个路由器告诉这个傻逼自己也能到这个网了, 只需要先到你那, 这样只需要5步. 这个傻逼一看自己本来就是走他那的, 他现在到那个网需要5步了, 是不是路变远了, 就把自己的路由表改成了6步到这个网. 这样捯饬半天, 等他们俩都把自己路由表折腾到16的时候, 两个傻逼才知道这个网死了. 所以不能把无限大设的太大, 要不然这俩傻逼搞半天都搞不懂这网死了. 这个叫, 坏消息传得慢. RIP属于应用层的协议, 他的报文通过UDP发出去. OSPF 这个方法比较强一点, 不是一种分布式算法. 每个路由器定时戳一戳身边的路由器看看他还活着没. 如果发现旁边有个人死了或者莫名其妙突然多了个人, 就赶紧发个通告告诉旁边的人自己身边人变了. 旁边的路由器收到这个通告的时候改一下自己的链路数据库, 并且把这个通过告诉给自己身边的其他人. 这样, 每个人的链路数据库都保持到了最新的拓扑情况. 这个链路数据库记录了整个网络长啥样. 然后每个路由器就能用Dijkstra记录出来到每个地方最近的路线了, 按照这个路线发给下一个人就行. 链路数据库保存了每个路由器的位置, 还有每条线路的速度延迟之类的数据, 不再像RIP只使用跳来衡量了. OSPF的报文直接作为IP数据报的数据, 加个IP头就送给链路层了, 不用UDP, 可以看成传输层的协议. 但是一个自治系统太大了, 路由器可能存不下这么大的链路数据库, 更新链路数据可也很占带宽. 所以OSPF又把一个自治系统分成了一堆区域, 然后一个主干部分把所有区域连起来. BGP BGP属于外部网关协议, 是用于连接不同自治系统的协议. 每个自治系统需要找一个路由器当发言人, 然后每个自治系统之间的发言人刚开始会把自己的BGP路由表全部发出去, 之后只有当自己的自治系统网络结构发生变化之后才发. BGP的报文使用TCP发出去, 所以BGP属于应用层协议. BGP使用的是路径-向量协议. 多(组)播 就是一个数据报用个组播地址, 到了一个路由器这个路由器就会把他复制几份发给不同的端口. 组播地址使用D类地址 组播地址需要换算成多播MAC地址, 但是D类地址中间有28位自由的, 但是换算成MAC地址只有23位与IP地址有关, 有5位信息丢失. 但是在一个网络中这样的冲突概率很小, 所以就不管了.","categories":[{"name":"笔记","slug":"笔记","permalink":"https://orangecheers.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://orangecheers.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络期末预习笔记1-数据链路层","slug":"Chapter11-15","date":"2021-07-10T07:54:00.000Z","updated":"2021-07-10T08:34:24.000Z","comments":true,"path":"2021/07/10/Chapter11-15/","link":"","permalink":"https://orangecheers.top/2021/07/10/Chapter11-15/","excerpt":"","text":"今年一如既往还是期末预习, 计网学了大概一星期, 比其他所有课学的时间加起来都长. 学的也比较认真(埋下了操作系统翻车的伏笔), 中间还记了笔记, 主要记了数据链路层网络层和传输层(期末考试错了一个物理层一个应用层的题), 因为刚开始预习的时候记笔记的时候记了一天笔记都丢了, 所以这个笔记后来也被放到了github上. 最后计网总评91分, 课程排名在前5%. 感觉这种知识点散到离谱的学科速成的时候记笔记还是挺有用的. Chapter 11 数据链路控制 HDLC 数据链路层可以提供不可靠的传输, 也可以提供可靠的传输. HDLC就是一种可靠的传输. HDLC帧 标志(8位), 01111110, 为帧的开始标志. 地址(8位) 控制字(8位), 有三类：信息帧, 监督帧, 无编号帧 信息, 长度任意 帧检测序列, 16位 结束标志 PPP是面向字节的, HDLC是面向比特的 Chapter 12 多路访问 当一群东西共享介质的时候, 就需要点方法来控制这些东西说话. 控制多路访问的方法有三类: 随机访问 ALOHA CSMA CSMA/CD CSMA/CA(十四章) 受控访问 预约 轮询 令牌 通道化 TDM FDM ... 随机访问 ALOHA 纯ALOHA协议 发, 发不出去就等 rand(0,2^k-1)*T 再发, k++;(截断型二进制指数退让算法). T可以是Tp或者Tfr. 可能冲突时间是 2 /times T_{fr} 意思是在这一帧发之前的Tfr和开始发之后的Tfr内都有可能有人再发, 这时候发就会干扰这一帧. 吞吐量 S = Ge^{-2G}, G = /frac{1}{2}的时候取S_{max} G是Tfr内系统产生帧的期望. 时隙ALOHA协议 纯aloha协议太拉了, 就有时隙ALOHA协议, 时间被分成了离散的. 可能冲突时间少了一半, 只有Tfr 吞吐量 S = Ge^{-G}, G = 1的时候取S_{max} CSMA协议 CSMA全称是载波侦听多路访问, 意思就是在发之前他会探一下信道是否空闲. CSMA常用有三种策略: 1-坚持型CSMA 就是一直探, 能发就赶紧发, 不能发就一直探. p-坚持型CSMA 一直探, 能发就以p的几率发, 否则就等一段固定的时间再探 非坚持型CSMA 能发就发, 不能发就随机延迟(二进制啥玩意的方法延迟) CSMA/CD协议 带冲突检测的CSMA, 主要是CD部分. 还是一直探, 能发就发, 发的时候听, 如果发现自己发的和听的不一样, 就说明冲突了, 停下来, 随机延迟避让. 争用期/冲突窗口是 2 /times /tau , 意思是这段时间听不到错误不代表一定能不冲突地发出去. 但是过了这段时间, 就说明信道抢占成功, 一定能发出去了. 对于10M的以太网, 争用期规定为51.2us, 意思是只要把前512bits(64B)发送出去, 那以后就没人能干扰自己了. 同时, 以太网的最小帧长也是这样来的, 64B. 要注意的是, 对于100M, 1000M的以太网, 最小帧长也是64B, 只不过把争用时间减少了, 同时最大的网线长度也减少了. 还有, 只有半双工的环境下需要CD, 全双工是不需要CD的. 截断型二进制指数退让算法 先选个基本时间, 一般就是 2/times /tau . 然后k刚开始等于0, 碰撞一次就+1, 然后等待rand[0,M] * 基本时间, 其中 1 /leq N /leq 10, M = 2^{N}-1 10 /leq N /leq 15, M = 2^{10}-1 = 1023 N = 16, 直接扔了, 爬直接扔了爬 受控访问 我感觉就考一个令牌. 令牌 就是网络是个圈, 有个特殊的帧在圈里转, 拿到了帧的才能发数据. Chapter 13 以太网 局域网是形容网络规模的, 以太网是在局域网中一中最受欢迎的解决方案. 局域网的控制方法主要有CSMA/CD, 令牌总线/令牌环. 前两种用于线性网, 最后一种用于环形网. 以太网有两个标准: DIX Ethernet V2 802.3 主要都用第一种, 第二种基本没人用了. 所以我大胆推测只考第一种. 注意, 数据链路层不提供重传, 以太网也是不可靠的. 但是这并不代表以太网一定不会重传. 以太网会在确定自己数据对面一定接收不到的时候重传, 例如CSMA/CD中数据都没发完, 那肯定要重传的. 但是当他不确定对方是不是没收到的时候, 他就不会重传, 所以他还是不可靠的. 以太网的MAC帧 同样的, 以太网还是根据标准不同有两种MAC帧, 主要只看V2版本的. 前导码, 8Bytes, 这个是物理层加进去的, 前7B叫前同步码, 最后一个Byte叫帧开始定界符. MAC帧是不需要结束符的, 因为每一个帧都有开始符. 目的地址, 源地址, 都是6Bytes. 类型. 这个是说明这个帧交给上层哪个协议处理的, 例如IP数据包. 好像不重要. 数据, 长度为46-1500Bytes. 46是因为一个帧最小64B, 减去18Bytes的其他东西, 这个东西至少46B. 1500是规定的, 记住就好. 如果不到46B, 就补成46B. 校验码, 就是CRC. 校验了包括目的地址开始到数据结束的所有东西, 但是不包括前导码, 因为那个是物理层的哈哈. 802.3的格式与V2的区别: 帧起始标志不一样. 没有类型了, 改成了长度. 以太网的MAC层提供的是无连接不可靠的服务, 但不代表所有链路层的东西都是无连接不可靠的. 物理层 传统以太网主要有四种介质: 10Base5 (粗缆) 10Base2 (细缆) 10Base-F (Fiber 光纤) 10Base-T (T啥的 双绞线) 第一个数字表示速率, 第二个Base基带信号, 采用曼彻斯特编码. 后面的数字表示电缆最长距离, 500m/200m(实际上185m). MAC地址 MAC地址, 6个字节. 第一个字节最后一位表明单播还是组播. 最后一位是0是单播地址, 是1就是多播地址. Chapter 14 无线局域网 协议IEEE 802.11 还是定义了物理层和数据链路层. BSS就是一小块连在一起的移动站和一个基站, BSS内部他们可以互相通信. 一个BSS可以是独立的, 也可以连到一个主干分配系统(DS)组成一个ESS. ESS也可以通过门桥连到其他标准的局域网, 例如有线的因特网, 这里的门桥就相当于网桥. 两大问题 隐蔽站问题 A想发给B东西, A看没人发东西, 就给B发了, 但是另一个方向C也在给B发东西A看不到, 数据就坏了. 暴露站问题 A在发给B东西, 同时C也想给D发东西, 虽然A发的东西D接收不到, 但是C能接收到, 就不敢发, 浪费了时间. 这些问题决定了无线局域网不能使用CSMA/CD协议. CSMA/CA协议 带有碰撞避免的CSMA. CSMA/CA主要有三个东西: 帧间间隔(IFS), 竞争窗口和确认. CSMA/CA有好多种帧间间隔, SIFS/PIFS/EIFS啥玩意的, 不同的东西发之前会等不同的IFS, SIFS是最短的, CTS/ACK什么玩意的之前就只等一个SIFS. 竞争窗口就是等完IFS之后,判断一下是否空闲, 然后类似二进制退让算法, 他会等R(随机的, 就是二进制退让算法那样随机)个slots, 每个slots之后都会判断信道是否空闲, 如果不空闲就卡住, 等空闲了继续从刚刚数到的位置继续数. 确认就是发送之后他还要确认, 如果超时了还没收到ACK, K++, 从等IFS之前再重来. RTS/CTS 为了解决隐蔽站问题, RTS/CTS方法可以选用: A要发给B帧之前, 先发一个RTS, 让A旁边的傻逼们闭嘴. B收到RTS之后, 再发一个CTS, 让B旁边的nt们小点声. 然后A和B就可以bb了. 暴露站问题解决成本要大于效益, 所以就不解决了. 要解决的话要把数据信道和控制信道分离. DCF/PCF 802.11的MAC层有两个子层, 下层是DCF, DCF之上有PCF. DCF采用了CSMA/CA协议. PCF在DCF之上实现, 采用轮询访问协议. RTS/CTS是独立于他们的可选项, 与DCF/PCF好像无关. PCF的优先级要比DCF高. 帧格式 我感觉不考. 控制帧有三种:RTS/CTS/ACK帧 寻址机制 非常罕见的ppt说的我能听懂. Chapter 15 连接局域网主干网, 虚拟局域网 物理层连接 中继器 是regenerator(数字信号), 不是amplifier(模拟信号). 中继器就是集线器的前身. 无源集线器 就是直接连起来而已 有源集线器 还可以对信号放大再生. 以上都是物理层设备 数据链路层连接 网桥 数据链路层设备, 相较于物理层设备, 他有更复杂的控制逻辑, 可以避免不必要的转发. 透明网桥 透明网桥的透明体现在它可以即插即用, 不需要人工配置转发表. 透明网桥的自学习算法 透明网桥的自学习算法可以帮助透明网桥配置转发表. 其实就是一个设备给他发帧, 帧里面肯定有他的MAC地址, 网桥也知道他从哪个端口发过来的, 就在他的转发表加上一个他的MAC地址和端口的行就行了. 同时, 他会记录这个帧进入的时间, 并且在转发表有这一项的时候更新时间. 如果转发表没有这个MAC地址, 他就广播帧. 生成树 为了避免数据在网络内转着跑, 透明网桥会使用生成树算法来生成树, 具体算法考研不做要求, 我猜考试也不考. 源选径网桥 用一个神奇的好像不考的算法得到了最佳路由, 反正知道他是最佳路由就好. 最佳路由并不是一定就是经过路由器最少的路由, 他可能也是花费时间最少的路由, 这样也有利于负载均衡. 一个路由器数据太多卡住了, 就会换一个可能更远的路由. 二层交换机 普通的交换机一般指的是二层交换机, 就是工作在数据链路层的交换机. 他就是一个多端口的网桥. 一般工作在全双工模式. 交换机总容量 交换机的给每个用户的带宽并不会因为用户的增加而减少. 相反, 用户增加后, 交换机的总容量也会增加. 全双工下: 总容量=用户数*带宽 * 2 半双工下: 总容量=用户数*带宽 题目不说, 默认半双工 交换机的两种工作模式 存储转发 先全接收完, 检查数据是否正确, 正确才去查转发表转发. 直通式交换 收到目的地址就直接一个一个位发出去, 不检查了. 这种方式很快, 但是缺乏安全性, 也不支持不同速率端口的交换. 交换机和网桥差不多, 自学习转发表 冲突域和广播域 冲突域 冲突域就是只用第一层设备连接起来的物理层链路, 这种链路中只要有一个人发东西, 所有人都能听到, 如果在以太网中, 其他所有人还都不能说话, 所以叫冲突域. 如果中间加一个二层设备, 例如交换机, 他会隔绝不需要转发的帧, 只有当他不知道发给谁的时候他才会广播. 这样, 这个交换机就起到了隔离冲突域的作用, 所以冲突域是一个一级网络的概念, 二层设备可以隔离冲突域. 广播域 广播域就是能收到广播的范围, 交换机在广播的时候, 会把与自己相联的所有设备全部广播一遍, 所以二层设备不能隔离广播域. 但是路由器默认不转发广播, 所以路由器这种三层设备可以隔离广播域.","categories":[{"name":"笔记","slug":"笔记","permalink":"https://orangecheers.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://orangecheers.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"2021 ICM/MCM 游记","slug":"2021ICM-MCM-travel-notes","date":"2021-02-13T08:11:00.000Z","updated":"2021-07-08T13:38:23.000Z","comments":true,"path":"2021/02/13/2021ICM-MCM-travel-notes/","link":"","permalink":"https://orangecheers.top/2021/02/13/2021ICM-MCM-travel-notes/","excerpt":"Day -∞ -- Day 0 考试周前觉得自己要是连考试周都能熬过去的话, 这世上就没什么能难倒我的了.","text":"Day -∞ -- Day 0 考试周前觉得自己要是连考试周都能熬过去的话, 这世上就没什么能难倒我的了. 所以我和wwy十一月就打算今年去水一下数模美赛, 混混分, 体验一下数模到底是啥. zirrtu也早就劝我去水一下, 说他去年啥都不会大数据题跑了个nlp就拿了个M奖, 报名费600奖金3000, 搞得我也心动了. 本来就我和wwy, 想再找一个队友. 然后创创说可以加入. 我分了一下, 创创会latex, 就让创创写论文; 我不会matlab, 就让wwy当编程. 我就自然地成为了建模. 后来想一下我好像是因为太废物了才当的建模, 实际也证明了我确实是个废物. 然后都准备给学校报名了, 创创npy把创创拉走了, 我们又去找队友去了. 然后找到了oxy, 她来写论文. 创创在那边好像是编程, 太全能啦. 然后是联系老师, 因为我们之前没有任何数模经验(实际上我是打过校赛的只不过啥奖都没拿我就没写上去), 我们被分到了见习梯队, 后来听说好像即使没拿奖说你打过校赛都不是见习梯队, 不过这个见习梯队不仅不是劣势, 反而在联系老师的时候成了优势. 我们三个ACMer的特点还是很明显的, 就是编程和数据处理什么的都不用费太大功夫学. 然后尝试联系了一下听说是学校最强的张胜利老师, 据说他很难联系上. 然后联系了一个我上学期的线代老师. 这个线代老师主要就是管的不严, 适合我这种佛系选手. 给老师发的邮件里就写了我们三个人ACM相关的奖没想到刚给张胜利老师发了邮件, 给线代老师发了邮件, 张胜利老师就发邮件同意了. 我只能尴尬地又给线代老师发了邮件解释. 能这么快联系上张胜利老师我估计主要是因为我们是见习梯队, 因为每个老师的正式队和见习队都是分别限制名额的, 可能他认为见习梯队都差不多, 然后也不会挤占正式队名额, 加之我们联系的又早, 就直接同意我们了(说到底还是废物). 后来发现我们高估了考试周的难度, 高估了我们浴血重生后的勇气. 看了一星期数模相关的东西, 我只想退钱. 感觉数模还是太开放了, 和acm那种大部分时候只有一种正确解法, 并且所有地方都要很完美地考虑清楚的东西相比, 数模给我的不安全感很大. 作为一个无可救药的完美主义者(其实就是废物), 一个很模糊的, 可能有一点点逻辑问题的东西都会让我纠结很久, 完全不敢进行下一步思考, 而实际上数模里这些东西都是无伤大雅的. 我也认识到了我这些问题, 所以我尽量不让自己多想, 告诉队友们如果他们都觉得没问题我还在这瞎bb的话就别听我的继续做下一步. 学校安排的数模训练很紧, 但是这是针对正式队的, 见习队可以选择参加. 我们想还是先学点东西再参加吧, 啥都不会也编不下去, 结果直到最后我们也没有完整的练过一个题(还是废物). 平时就一起跟301一起学数模, 听301里唯一有数模经验的99讲东西, 开了很多题最后都没做到第二问, 做了个阿片的题唯一收获就是别选C题(太废物了). 还有一个奇怪的公告署名, 就很奇妙, 现在也不知道是什么情况. Day1 五点多就都起了, 目标很明确, 直接开了D题. 我先花了四五十分钟把题目翻译了一遍, 不清楚的地方标了一下, 然后吃个早饭就开始建模之旅. 题目是The Influence of Music, 挺巧的, 前一天跟301聊天时还说到除非出一个音游题要不然我肯定没输出, 看到这个题目我以为真的是音游, 然而实际上跟音游没啥关系. 之前做特斯拉那题对找数据有了心理阴影, 看到这题说只允许使用题目给的数据集还是很开心的, 不用去找这么多奇怪的数据了. 第一问让建一个图, 不管用什么算法, 怎么建图他都说好了, 先把图建出来然后画一个图充个数. 这么大的图要画的话肯定要用gephi, 但是我不会(就纯废物), 就先让wwy画了一个图. 不知道他怎么调了色, 做出来是这个画风的: 先不管了, 我们三个先口胡出了第一题的模型, 然后一起商量了一些关键词的中英文名称, oxy就去写论文了, 因为是个缩点dp, wwy写了好长时间才出来, 大废物我感觉自己没什么事做, 就去画了几张图. 画图感觉不用gephi还是不行啊, 一个五个点六个边的图我用ppt拼了十几分钟才满意, 拼好之后果断学gephi, 而且发现gephi还能导出svg图片, 然后导入到ppt里再美化, 我感觉我马上就成为画图大师了. 吃完饭, 我去睡了两小时(懒狗). 醒来之后发现wwy已经写好代码了, 跑出了结果. 然后我脑子里构思了一张特别帅气的图片, 但是限于ppt技术我不确定能不能做出来, 就先放了放, 然后一起去嘴第二题. 第二题就感觉力不从心, 完全毫无逻辑毫无新意(实际上整个题也没什么逻辑和新意), 然后觉得我不是编程所以就让wwy继续去实现第二题, 我去画那个特别帅气的图片(说到底就是条懒狗). 晚饭之后我画出来了, 但是总觉得差点意思, 还是技术不够, 差不多得了. 配色实在太丑了, 我已经不忍心看了. 其实本来是想放10个人的, 但是实在调不好布局, 就只放七个人了. 晚上十一点下班了, 自闭了好长时间才睡觉呜呜. Day 2 第二天八点准时起床, oxy把昨天的论文发了一下, 我没仔细看内容只是把图片看一下, 然后一些语法错误改了一下(事后证明这里出现了大问题), 继续嘴后面的题了, 嘴完之后又去画图了. 中午吃完饭又睡了两小时(纯懒狗), 然后下午确定了一下哪些题认真做做, 哪些题靠嘴建模. 然后我又去画图了, 期间看了看wwy的数据, 提出一些错误的建议, 想一想哪些地方可以画图. 晚上我觉得我不能再这样划水下去了, 我去翻译了几段wwy写的中文论文发群里了. 十一点半下班. Day 3 第三天八点准时起床, 然后嘴了几个方法就扔给wwy实现去了, 我继续去画图. 跑出了个155MB的数据, 处理的时候wwy电脑还崩了. 套了第一个模型又嘴了几个完全离谱的方法, 跑出了发现结果不是很好, 对着结果改方法才做出了比较好的结果. 然后发现svg图片放到oxy那边字体格式什么的都不对, 因为svg图片里不包含字体. 然后我说图片什么的先放放, 等我最后研究好怎么导出pdf格式的图片再放图片(还是懒狗). 然后又去快乐画图了. 画了一个立体效果的图, 但是丑到天际, wwy安慰我说画的还可以. 这两天的游记写不下去了, 我好像就是什么都没干, 我是废懒狗. Day 4 - Day 5 一大早正准备进腾讯会议, 发现腾讯会议号被封了, 我还是第一次知道腾讯会议还能封号. 没办法, 也懒得去折腾其他替代品了, 就只能去QQ语音了, QQ语音共享屏幕还不好搞, 以前用会议我都是共享屏幕防止自己摸鱼的, 现在共享屏幕都懒得搞了, 毕竟我是懒狗. 折腾了一上午, 大概把题目全部构思好了, 然后就剩吹论文了. 下午wwy去写了给ICM的Document, 我去写了一下模型的Weakness, 感觉全篇论文我最有自信写的就是这一块, 要不是写太多不是很好我能写十页. 晚上我把摘要写好了, 然后给他们看了一下, 改了几遍感觉没啥问题, 准备做最后的修改了. 我是很怕熬夜做事的, 特别是这种要合作熬夜干事, 而且还开了语音. 到了晚上我就会很容易暴躁, 喜欢喷人, 然后做一些很奇怪的事情. 再加上我是个死心眼, 有一点问题我都受不了, 所以就很容易因为一点点小问题激动. 把文章大概从中间到尾看了一遍, 找到了一些语法错误, 一些格式不统一的问题后, 到了两三点感觉没啥问题都准备交了, 看了一下第一个模型的表述, 然后心态就崩了. 当时就感觉第一个模型一点都没说清楚, 有删掉自己重写的冲动, 然后一直在语音里发牢骚. 不过后来想想自己本来也没干啥, 当时这个模型我去写就好了. 本来想用oxy的latex文件直接改好发给他们的, 然后发现他的latex文件我怎么都编译不了, 心态又崩了, 又哭又骂, 跟个傻逼一样哈哈. 然后只能通过共享屏幕用键盘指点江山, 改好已经是四点了, 心态也平静的差不多了. 把参考文献格式统一了一下, 最后检查了几遍论文的标题和图表标题的格式统一, 五点多基本完成把论文交了. 回到了懒狗温暖的床上. 临睡前听说很多人邮件没发过去, 确认了邮件发过去了才安心睡觉. 睡一觉起来下午就出去玩了, 一下午吃了两顿饭, 回家路上都走不动了. Day 6 官网更新了, 邮件Received, 放心了, 希望能有个S以上的奖. Day 7 突然看到昨天数模大群里要把源文件什么的发给学校, 看截止日期过了我们就没管, 反正西电不差我们一个队. 除夕, 晚上邦邦老师说要在大群里发一个红包, 我跟99守着零点抢红包但是她抢到了我没抢到, 我是废物. 数模好累, 如果还有下次一定要提前商量好论文咋写, 这次的最后一晚上太难顶了.","categories":[{"name":"游记","slug":"游记","permalink":"https://orangecheers.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"Logistic回归初步","slug":"logistic-basis","date":"2021-02-12T10:27:47.000Z","updated":"2021-07-08T14:45:47.000Z","comments":true,"path":"2021/02/12/logistic-basis/","link":"","permalink":"https://orangecheers.top/2021/02/12/logistic-basis/","excerpt":"咕了好长时间的Logistic回归, 今天晚上不小心睡着了现在不困就写一点.","text":"咕了好长时间的Logistic回归, 今天晚上不小心睡着了现在不困就写一点. Logistic回归主要是解决二分类问题, 普通的线性拟合拟合出的函数值域是实数集, 通过套一个激活函数就可以把这个实数集映射到上[0,1]. 常见的激活函数之一是Sigmoid函数: S(x) = \\frac{1}{1+e^{-x}} 这个函数有个性质, 就是求导之后可以用原函数的一个简单的多项式表达, 一会推导的时候有用: S'(x) = S(x)(1-S(x)) 然后就可以用之前的线性拟合套一个这个函数拟合, 因为这个函数可导, 推导过程和线性拟合的推导过程差不多. 如果反过来写, 把y = S(w^T x)的x解出来, 可以写成: ln \\frac{y}{1-y} = w^T x 其中这个ln \\frac{y}{1-y}又叫对数几率, y是概率, 在[0,1]上, 通过这个函数映射到R上, 实际上Logistic回归就是用线性拟合去拟合对数几率. 关于Loss函数, 有些文章直接给出了这个Loss函数的表达式, 然后简单的定性说明一下, 实际上这个函数就是极大似然函数. (只在期末考试前学了一天概率论的我记住的为数不多的东西) 对线性拟合的系数矩阵进行极大似然估计, 写出似然函数L(w), 然后求个导就能用梯度下降了. 推导过程就不写Latex了, 太麻烦了, 放一个我之前自己推导的草稿吧. 还有, Sigmoid函数是任意阶可导的, 所以牛顿法也是可以用的. 下面都是我瞎想口胡的, 还没来得及验证. Logistic回归是解决二分类问题的, 得到的结果是一个点属于其中一类的概率. 顺着这个思路, 我想如果把里面的一个数改成一个向量, 然后函数得到的结果是也是一个向量, 向量的每一个元素代表这个点属于这个类的概率, 这样就可以解决多分类问题了. 按照Logistic回归的想法, 首先得到的是一个在R上的数, 在我这个多分类模型的想法中, 首先就要得到一个R^n的向量, 其中每一个元素都是单独线性拟合出的结果. 然后对这个向量加一个激活函数, 就可以得到最终的结果向量. 这个激活函数需要把一个R^n的向量映射到一个[0,1]^n的向量, 并且这个向量元素加起来等于1. 查了一下, 都用的softmax做到这个. Loss函数也按照极大似然估计的思路来推, 应该就可以实现多分类了, 有时间去试验一下.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数理","slug":"数理","permalink":"https://orangecheers.top/tags/%E6%95%B0%E7%90%86/"}]},{"title":"梯度下降实现线性拟合矩阵推导及实现","slug":"gradient-descent-linear-fitting","date":"2021-02-11T01:58:27.000Z","updated":"2021-07-09T02:33:08.000Z","comments":true,"path":"2021/02/11/gradient-descent-linear-fitting/","link":"","permalink":"https://orangecheers.top/2021/02/11/gradient-descent-linear-fitting/","excerpt":"","text":"梯度下降实现线性拟合矩阵推导及实现 acm退役选手正在尝试新东西, 刚开的机器学习的坑. 实现线性拟合实际上还是用高中最小二乘的那种东西, 只不过不是通过计算直接求得拟合的参数, 而是用梯度下降的方法计算逼近参数. 用一个二维的直线拟合做例子. 高中就学过拟合实际上就是要找到一个直线 来尝试代表一组数据, 来达到预测的目的. 为了让预测的结果更加准确, 所以要让这个直线尽可能的逼近仅有的数据. 最小二乘法里衡量这个直线对这些仅有的数据的准确程度是用每个数据的真实值与估计值差的平方和, 也就是 \\Sigma_{i=1}^{n} (y_i-\\hat{y_i})^2, 这个值越小, 就说明这个直线对这些数据越准确. 在这里给这些东西换个名字, 把 h(x) = \\theta_0 + \\theta_1 x 叫做估计函数, 把 J(\\theta_0,\\theta_1) = \\frac{1}{2m}\\Sigma_{i=1}^{n} (y_i-h(x_i))^2 叫做误差函数, 也就是loss. 梯度下降算法是很好理解的, 但是因为矩阵的运算我运用不是很灵活, 线代当时也是速成的, 所以刚开始我并没有用矩阵来实现, 后来想了一段时间才写出来了矩阵形式的梯度下降. 因为我之前没看过别人怎么实现的梯度下降, 所以下面的推导和实现方法的一些细节都是我自己决定的, 很可能与主流写法不一样, 麻烦许多, 这里先记录一下我自己的思考过程, 一会学习了别人的代码之后再来补充. 因为要用矩阵实现, 所以首先要把这些函数矩阵化. 对于多参数的估计函数, 我们要估计的参数可以写成一个向量 [\\theta_0, \\theta_2,\\dots, \\theta_{n}]^T, 先叫他参数向量, 记作 \\Theta . 因为有个常数项, 所以要估计的 \\theta 个数要比数据的参数多一个. 同时我们把训练数据写成向量形式, 因为训练数据的第一个要与参数向量的 \\theta_0 相乘, 所以这一位可以用一个 1 来补上, 这样这个向量就可以写成 [1,x_1,\\dots,x_n], 这样估计函数就可以写成: h(X) = X \\cdot \\left[ \\begin{matrix} \\theta_0 \\\\ \\theta_1 \\\\ \\theta_2 \\\\ \\vdots \\\\ \\theta_n \\end{matrix} \\right] = X \\cdot \\Theta 同时我们可以把训练集写成矩阵形式: X = trainx = \\left[ \\begin{matrix} 1 & x_1^{(1)} & x_2^{(1)} & \\cdots & x_n^{(1)} \\\\ 1 & x_1^{(2)} & x_2^{(2)} & \\cdots & x_n^{(2)} \\\\ 1 & x_1^{(3)} & x_2^{(3)} & \\cdots & x_n^{(3)} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & x_1^{(m)} & x_2^{(m)} & \\cdots & x_n^{(m)} \\end{matrix} \\right] \\space \\space Y = trainy = \\left[ \\begin{matrix} y^{(1)} \\\\ y^{(2)} \\\\ y^{(3)} \\\\ \\vdots \\\\ y^{(n)} \\end{matrix} \\right] 这样我们计算 h(trainx), 就可以惊奇的发现得到一个估计量组成的矩阵. 这是loss函数就可以写成 J(\\Theta) = \\frac{1}{2m}||h(X) - Y||^2 然后我们需要求 J(\\Theta) 对 \\Theta 的偏导, 这是一个标量对向量的偏导, 但是这个模长不是很好处理, 所以我们转化成向量对向量的偏导, 即把loss函数写为: J(\\Theta) = \\frac{1}{2m}(X\\Theta - Y)^T (X\\Theta - Y) 求全微分: dJ = (Xd\\Theta)^T(X\\Theta-Y) + (X\\Theta-Y)^T(Xd\\Theta) 整理得: dJ = 2(X\\Theta - Y)^TX d\\Theta 可得: \\frac{\\partial J}{\\partial \\Theta} = 2X^T(X\\Theta-Y) 每次迭代让当前的 \\Theta := \\Theta - \\alpha\\frac{\\partial J}{\\partial \\Theta} 即可, 其中 \\alpha 为学习率. 这样, 梯度下降的所有过程都有了数学形式, 也就很好实现了. 第一次写觉得自己不可能写对, 跑一遍果然成了梯度上升算法, 查了半天没查出错, 把学习率调低就行了...我居然一遍写对了. 矩阵求导还是太难了, 很不熟练, 以后再多研究研究这些数学基础, 好喜欢这种用数学推导出的有用的东西. 附上代码: import numpy as np datax = [0.50,0.75,1.00,1.25,1.50,1.75,1.75,2.00,2.25,2.50,2.75,3.00,3.25,3.50,4.00,4.25,4.50,4.75,5.00,5.50] datay = [10, 22, 13, 43, 20, 22, 33, 50, 62, 48, 55, 75, 62, 73, 81, 76, 64, 82, 90, 93] n = 1 m = len(datax) trainx = np.zeros((m,n+1)) trainy = np.zeros((m,1)) def calch(t): return np.dot(trainx,t) def calcJ(t): loss = calch(t) -trainy loss = np.dot(loss.T,loss) return loss/(2*m) def calcJd(t): lossd = 0 lossd = np.dot(trainx.T,np.dot(trainx,t) - trainy) return lossd/m def init(): global trainx global trainy for i in range(m): trainx[i] = [1,datax[i]] trainy[i] = datay[i] return learning_rate = 0.001 def gradient_descent(t): tt = t - learning_rate * calcJd(t) #print(t0,t1,calcJ(tt0,tt1)) return tt print(datax) init() t = np.zeros((2,1)) for i in range(1,100000): t = gradient_descent(t) print(t) print(t)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数理","slug":"数理","permalink":"https://orangecheers.top/tags/%E6%95%B0%E7%90%86/"}]},{"title":"IEEE Xtreme 14.0 游记","slug":"IEEE14-travel-notes","date":"2020-10-26T18:55:16.000Z","updated":"2021-04-30T09:34:07.000Z","comments":true,"path":"2020/10/27/IEEE14-travel-notes/","link":"","permalink":"https://orangecheers.top/2020/10/27/IEEE14-travel-notes/","excerpt":"IEEE极限编程, 从周六早上八点(UTC 0点)一直到周日早上八点结束, 每小时都会放出新题目. 第一次打这种比赛, 属实难顶.","text":"IEEE极限编程, 从周六早上八点(UTC 0点)一直到周日早上八点结束, 每小时都会放出新题目. 第一次打这种比赛, 属实难顶. Day 0 星期五上午体育课体测跑一千米, 一年没锻炼的我居然只比去年慢了十秒钟, 不过四分四十秒还是没及格, 而且跑完之后跟死了一样, 课上第一批跑的等到下课半个小时才从网球场的椅子上站起来一步一步挪回宿舍, 下午还发烧了. 晚上又累又困十一点多就睡了. Day 1 早上六点五十起床, 收拾收拾磨蹭磨蹭吃点饭正好八点零一到lyf老师的电工实验室. 队友还没来, 我先开了电脑看了下题, 发现前五分钟只有个神必环境测试题, 让我随便输出一个东西, 输出啥都是0分. 五分钟结束后放了个三道题. 一个傻逼签到题, 随便打打交了就过了. 然后一个计算几何和一个大模拟. 队友们来了, 我给他们解释一下计算几何的题意, 就去写大模拟了. 傻逼计算几何用的支持向量机当的背景, 要我们做一个线性分类: 给我们平面上两种点, 问能不能用一条经过原点的直线给他们分开. zirrtu没看到要经过原点, 直接上python交机器学习, 折腾了半天没过一个点. 我大模拟打了一小部分, 测了一下样例发现我连有效单词数都没统计对, 应该是题目读错了, 但是没找到问题在哪, 就直接去支援计算几何了. 机器学习失败被迫想正统做法, 但是没人学过计算几何的我们很容易就会想到一些很高深的计算几何算法. 三个人往凸包上搞了半天, 交了几发都是0分. 比赛开始两小时, 第四题放出来了, 一个图论题, 但是我们没去看. 我继续钻研计算几何, 发现根本不用什么凸包, 直接把每个点极角搞出来然后瞎搞搞就可以了. 给他们讲了一下, 他们也觉得毫无破绽, 然后我们准备去吃饭了. 临走之前看了一下第四题, 就是给一个无向图, 每次查询两个点之间路径必须经过的点. 出去吃饭的时候我们开始嘴第四题的算法, 我们想两点之间任意一条路径上不在环上的点都是必须经过的点. 然后好像是先做一个生成树, 然后枚举每个非树边, 这样就能找到所有的环, 用树剖可以标记这个环上的所有点, 然后查询两个点之间不在环上的点就行了. 后来忘了为什么弃用了这个算法, 找到了一个无向图缩环的模板. 吃完饭hx去打这题, 我开始打我嘴的计算几何. hx打着打着发现不对劲, 因为如果一个点在环内, 根据他在环内的位置, 会有不同个数的环和外界的联通点是必须经过的点, 而如果缩了环, 就无法得知这个点在环中的位置. 这题就这样放弃了. 然后我就开始了我长达几小时的计算几何自闭时间. 吃饭的时候放了一个水题, 他俩直接给过了. 我嘴的计算几何方法实现很麻烦, 而且一点点小的精度误差都会导致答案错误. 打了几小时,最多的也只是过了20%的点. 开始去看4小时放的一个构造题. 看了五分钟直接嘴了一个构造, 跟队友讲了一下也觉得天衣无缝. 交上去0分. 然后队友过来看, 找到了问题. 接着我又想了一个构造, 打了出来, 样例都过不去. 又自闭了. 回去继续计算几何. 自闭了一下午,毫无输出. 有人搬了一箱红牛和一堆水果进来了. 干啥啥不行,吃饭第一名. 五六点我就带着队友们买东西, 买了点面包,糖,咖啡和一包蒟蒻果冻. 然后就回去继续肝了. 过了一会hx发现我的第一个构造会只会在大于N/2列出事, 他把前N/2列的构造方法镜像到后N/2列, 然后又构造了一个方法填上了中间两列的空隙, 给我们讲了一下觉得毫无问题. 敲了一遍交了果然过了. 这时候发现又多了个水题, zirrtu已经给过了. 还打了几个暴力. 到了晚上, 我完全失去了战斗力. 出了一个奇怪的感觉是解方程的问题, 我用了个奇怪的线性规划, 打了个假到不能再假的暴力, 居然过了75分, 赛后发现这题75分还是高分, 只能说运气好. 出了一个更奇怪的题目, 给了一段Brain Fuck代码, 什么也没说, 有种CTF的感觉. 其实刚看到这个题目名字我就觉得不太对劲, 题目名字Furin Back, 正好是Brain Fuck的一个排列, 一打开果然就是一段Brain Fuck的代码, 还有一个奇怪的看起来像蛋白质结构的图. 题面只有一个代码, 我甚至怀疑是不是图片隐写, 这个图片里是不是藏了什么东西, 下下来binwalk了一下没找到什么, 就放弃了. 最后找了个BF解释器, 随随便便优化了一下, 就拿了个暴力分跑路了. Day2 zirrtu跑路了, 后半夜我也完全没输出. 从十点到第二天四五点我都是划水状态, 也没怎么睡, 就读读题, 拍拍创佬黑照, 出去看看西电的夜景顺便发个说说, 附和一下hx的想法说没问题. 后半夜全靠hx, 一个人感觉做了有四五题, 太强了. zirrtu还不起, 给他打了几个电话也没用. 六点多他起了, 让他继续去改改计算几何. 我做了个傻逼题. 计算几何最后也没有改对太多, 不过差不多就行了, 那题属实恶心. 最后一小时, 是个字符串题, 我想到了一个很对的算法, 但是交上去总是T一半. 结束后发现创佬跟我一样的做法, 他就A了. 然后发现string的有个地方用的不对, 导致复杂度不对了, 以后还是自己写哈希吧. 八点结束了, 去做分光计物理实验. 这是这期实验的最后一次实验, 所以一个教室只有八个人. 那个老师让我们不用调实验仪器, 直接大概做一下就行了, 然后当场把报告交了. 我头有点发热, 但是很精神, 可能是回光返照. 但是这样我还是做不出来实验现象, 无奈最后只能编数据. 事后才知道这个实验不调仪器根本不可能做出来实验现象. 做完实验中午吃个饭, 下午睡了一下午, 没事了, 结束了奇妙的极限编程+物理实验之旅.","categories":[{"name":"游记","slug":"游记","permalink":"https://orangecheers.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"带限制的最短路/二维最短路","slug":"2d-shortest-path","date":"2020-10-18T07:33:13.000Z","updated":"2021-04-30T09:35:50.000Z","comments":true,"path":"2020/10/18/2d-shortest-path/","link":"","permalink":"https://orangecheers.top/2020/10/18/2d-shortest-path/","excerpt":"最近遇到了好多这样的题,感觉应该是一类题. 这一类问题就是要求满足某一限制条件下的最短路,比如每一条边都有两种边权,要求路径上其中一种边权之和小于某个值的条件下的另一个边权最小的路径.","text":"最近遇到了好多这样的题,感觉应该是一类题. 这一类问题就是要求满足某一限制条件下的最短路,比如每一条边都有两种边权,要求路径上其中一种边权之和小于某个值的条件下的另一个边权最小的路径. 可以用状态的思想考虑,在dp时,状态设计的不好就会出现这样类似的问题,不好转移,dp中解决这种问题的方法就是重新定义状态.在这个图中,我们也可以重新定义节点.本来节点只有节点编号这个属性,我们把被限制条件限制的边权和加入到属性中,这样只需要在最后只考虑属性中的这一个边权和满足条件的节点就行了.对应到图上,就是把一个点拆成很多点,拆成的每一个点对应原来点限制边权不同时的状态. 举个例子,考虑这样一个图:每一条边有距离和花费,要求花费小于等于K的最短路.可以把图中的每一个点拆成K个点,每一个点对应经过原来点是花费了一个数的状态.这样只需要在这个新图中跑一个最短路,用距离当边权,最后寻找终点拆出的点中对应花费小于K的点的最短路. 其实拆点只是一个思考方式,真正写的时候不需要写拆点的代码,可以把点的编号(x)变成一个二维数据(x,k),把这一个二维数据看作是点的编号,代表x这个点拆成的对应花费为k的点.反映在dijkstra中,就是优先队列中原本的Node{d,x},d是源点到x点的距离,变成Node{d,x,k},d是源点到点(x,k)的距离.在松弛操作中,原本的三角不等式写成dis[to] &gt; dis[x] + e.d,其中dis的下标是点的编号.现在把点的编号作为二维数据考虑,就是disto &gt; disx + e.d,其中x和cost分别对应当前所在点的编号和到这个点的花费,换句话说,就是新图中这个点的二维编号. 模板题: Environment-Friendly Travel: https://codeforces.com/group/2l2uaz0vCx/contest/102501/problem/A 题意是在二维平面中,给你N个中转点和一个起点一个终点共N+2个点的坐标,中转点之间有一些点之间有一些交通方式,这些交通方式经过的距离都是两个点的欧几里得距离,但是每一种交通方式平均每单位距离的碳排放量不一样.同时你可以从起点开始,开汽车到任何一个点,然后经过各种交通方式折腾,在一个点开汽车到终点,这也是起终点和中转点的唯一交通方式,并且中转点之前不能用汽车,汽车也有碳排放量.让你求在经过距离小于B的情况下碳排放量最小的路径,坑点在于可以直接开车从起点到终点.就是个二维最短路模板题.","categories":[{"name":"算法","slug":"算法","permalink":"https://orangecheers.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://orangecheers.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"CCSP 2020 游记","slug":"CCSP2020-travel-notes","date":"2020-10-17T21:09:02.000Z","updated":"2021-04-30T09:32:27.000Z","comments":true,"path":"2020/10/18/CCSP2020-travel-notes/","link":"","permalink":"https://orangecheers.top/2020/10/18/CCSP2020-travel-notes/","excerpt":"由于在上个月的CSP取得了高达330分的优(sha)异(bi)成绩，这次有幸能公费参加一下这报名费只要800大洋的比赛。可能是线上举办的原因吧感觉这次CCSP的参赛门槛低了好多，上个月CSP还是IOI赛制，330分的全国排名甚至还不如我大一刚开学打的290那次高。","text":"由于在上个月的CSP取得了高达330分的优(sha)异(bi)成绩，这次有幸能公费参加一下这报名费只要800大洋的比赛。可能是线上举办的原因吧感觉这次CCSP的参赛门槛低了好多，上个月CSP还是IOI赛制，330分的全国排名甚至还不如我大一刚开学打的290那次高。 Day0 前一天晚上是西电MSC的新生见面会，作为一个mentor当然要去跟新生们抢蛋糕吃，还体验到了被一群围着拍照片是啥感觉。 玩完到九点多了，突然意识到我准考证还没打，正好创佬说他一会去实验室可以给我打，明天给我送过去，我就让创佬帮我打了。 晚上回寝室想去找舍友借一本C++ Primer防止他出阴间题，可惜没借到，只找到了我之前去图书馆借的Head First Java。 博客又出事了，修修补补的折腾到了一点。 Day1 八点签到，刚睡五个多小时的我六点五十就爬起来了，拉着fth一起吃个饭就到机房门口等创佬给我送准考证。七点五十五创佬还没来，QQ问他说他起晚了还在寝室，还好进机房不用准考证，8点签到也没有开始。 签到的时候还被问了一下有没有清真需求，搞得跟没有你就会给我猪肉吃一样。 发了一个袋子，里面有一些奇怪的零食还有水啥的，还有一本秩序册。又发了一个狗牌，狗牌挺好看的，就是名字写的太大了，感觉戴着他别人八百米开外都能知道我叫啥。 机房环境挺好，我还是才知道西电还有这么好的机房，鼠标键盘看起来都挺好用的，可惜我自己带了没用他的。 九点开局，开幕雷击，这不是上次CSP的题? 一看就是又出锅了，等了五六分钟那边修好了换了个压缩包自己下，但是下下来的zip压缩包又解压不了，折腾了半天unzip，重新下了一遍，发现下下来的东西变成pdf了，终于看到题了。 第一题是个大图论题，带限制的最短路，有30分的无限制的，拿到题直接想到了30分解法，但是当时觉得30分的解法改不了后面的 测试数据，就没着急打30分的，想想能不能再来一点分。时间过的很快，这时候已经过去快一小时了。 挣扎了大约半小时，放弃了，开始打30分的解法。修修补补打了半小时交了，正好30分。这时候看了一下榜，发现华北赛区已经一堆200分的了。 开第二题，一个超超超超超超超超超超超超超超超超超大模拟，花了十分钟构思了一下怎么设计存储，奔着76分的read+write+ls+unlink+commit+checkout去的。 虽然一开始是按照76分的构思，但是实现还是一点点实现的。刚刚把框架写好，闻到了一股香气。十一点半开饭了。 干啥啥不行，吃饭第一名。本来就坐在最后的我直接上去领盒饭，不得不说，这饭确实不错，应该是我在西电除了综合楼吃过的最好的一顿饭了，而且居然真的有肉，还有一个。 十分钟光速吃完饭，接着把read+write打了，交了上去正好二十分。这时已经快十二点了。 然后打ls+unlink，打完交上去，40分。这时评测已经很慢了，这个结果我交上去十分钟才下来。 感觉一切都很顺利，开始打commit和checkout。按照我设计的框架，这两个功能是很好实现的。而且之前的find函数什么的都是适配了这个功能的写法。 打完交上去，可能是之前太顺利了，交上去我直接回到第一题了。过了二十分钟评测结果出来了，还是40，有点慌了，这时候大概两点多。看了一下榜，lzy已经变成西南赛区第一了。 自己造数据都是过的，题目给的第一和第二个数据也是过的，随后在大样例里用merge前的大概二三十条语句测出了问题，研究了一下发现我把ls的细节理解错了。 开始改，改完已经两点五十了，突然听到监考老师说是以最后一次提交为准，我现在交肯定比赛前评测结果出不来，万一写挂了铜估计都没了，就没敢交。 下午三点比赛结束，70分爬了。苦涩的心情和寒冷的机房给我冻的瑟瑟发抖。 出来恍若隔世，毕竟已经七个多小时没见到太阳了。 下午到寝室有点困，但是不想睡觉，感觉下午四五点就睡觉太浪费大好时光了。骑个车去综合楼转了一圈，顺便买了点吃的。在综合楼头还有点晕，差点没死外面。 回来在tlb群里语音通话了一晚上，然后看到分赛区的奖，发现我70分还能拿个银奖，高兴了一下。然后就睡觉了。 Day2 早上九点多才醒，错过了lzy的获奖感言，进直播听了一下题解，发现听不懂就爬了。全国奖也出来了，果然又是个破铜。 总体没有特别发挥失常的地方，就是最后理解错题意有点可惜，我水平也就这样了。发了个说说显摆了一下我认识lzy，就去抄实验报告了。下午还要去打训练赛，晚上还要回来抄fth的电路作业，明天就要交了。下周还有IEEE Xtreme和小米的ICPC，真是忙碌划水又自闭的生活呢。","categories":[{"name":"游记","slug":"游记","permalink":"https://orangecheers.top/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"字符串专题","slug":"string-practice","date":"2020-10-17T09:21:22.000Z","updated":"2021-04-30T09:34:36.000Z","comments":true,"path":"2020/10/17/string-practice/","link":"","permalink":"https://orangecheers.top/2020/10/17/string-practice/","excerpt":"查缺补漏 冲刺icpc 前缀函数 前缀函数 \\pi[i] 代表在字符串 s 中, 以 i 结尾的字串中, 最长的相等的前后缀, 即前 \\pi[i] 个字符组成的字符串和后 \\pi[i] 个字符组成的字符串是相等的.","text":"查缺补漏 冲刺icpc 前缀函数 前缀函数 \\pi[i] 代表在字符串 s 中, 以 i 结尾的字串中, 最长的相等的前后缀, 即前 \\pi[i] 个字符组成的字符串和后 \\pi[i] 个字符组成的字符串是相等的. 对于字符串的第 i 个字符, 当前 i-1 个前缀函数都已求出时, 考虑求出 \\pi[i]. \\pi[i] 的值是前多少个字符和后多少个字符相等, 如果第 \\pi[i-1] + 1 个字符与新加入的第 i 个字符相等, 即之前字符串的前缀等于后缀, 如果新加入的这个字符等于之前相等前缀的后一个字符, 那么这个位置的前缀函数就是之前字符串前缀函数值加一. 如果不相等, 考虑前缀函数的前缀与后缀相等, 前缀一定是从1开始, 后缀一定在 i-1 结束. 并且显然, 此时新加入的位置的前缀函数不会比之前字符串最后的前缀函数值大, 因为第 \\pi[i-1] + 1 个字符与新加入的第 i 个字符不相等. 这时我们需要找下一个需要匹配的位置, 来寻找新位置的前缀函数. 可能会成为新前缀函数值指向的位置的地方, 一定是前缀已经与前 i-1 个字符组成的字符串的某一个后缀相等的地方. 又因为这个新的前后缀长度一定小于上一个前缀函数的值, 所以这个相当于求前缀函数值代表的字符串的前缀函数, 这个是我们已经求过的. 然后继续比较这个前缀函数的前缀函数的后面一个字符是否与新字符相等, 这也一直循环下去直到实在找不到某一个满足条件的前缀后缀, 这时 \\pi[i] 等于0. (反正也没人看 我自己能看懂就行了) 这个算法的复杂度表面上看起来不是 O(n), 因为我们不仅要扫一遍每个字符, 并且在计算每个字符的前缀函数时还要去跳很多次. 但是考虑每一次跳的起点都是上一个字符的前缀函数值, 如果不考虑第一次就匹配成功, 前缀函数值+1的情况, 那么每次起跳的起点就是上一次跳的结束的点, 因为上一次是在前缀函数值处跳结束了才得到的这里就是前缀函数值. 然后考虑第一次匹配成功, 前缀函数值+1的情况. 因为前缀函数值小于等于字符串长度, 所以前缀函数值最多加 N 次, 最后跳的次数还是 O(N) 级别的. KMP 当匹配字符串与模式串每次都在第一个字符失配时,暴力算法的效率并不坏. 暴力算法的可优化之处在于当从某一个字符开始,后面已经与模式串匹配了很多字符,这时如果失配,下一个字符仍然要从模式串的首部开始匹配,浪费了计算资源. 求出模式串的前缀函数next,当在匹配串的某一位置失配时,可以知道当匹配串指针不动的情况下,模式串应该移动到何处才能让匹配串指针前的模式串与匹配串仍是匹配的.这是一个充分必要的条件,即next数组所求得的移动位置是不会多也不会少的,证明了正确性.由于这样匹配串的指针不会倒退,只会前进,所以匹配过程的复杂度是O(N)的,这时每次从匹配串字符开始匹配时模式串的移动距离就不重要了. (To be continued…) update: 字符串不是我负责了, 我爬了","categories":[{"name":"算法","slug":"算法","permalink":"https://orangecheers.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://orangecheers.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"KMP","slug":"KMP","permalink":"https://orangecheers.top/tags/KMP/"},{"name":"SA后缀数组","slug":"SA后缀数组","permalink":"https://orangecheers.top/tags/SA%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"前缀数组","slug":"前缀数组","permalink":"https://orangecheers.top/tags/%E5%89%8D%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"https://orangecheers.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"在JupyterHub使用基于sqlite3的第三方Authenticator","slug":"JupyterHubAuth","date":"2020-05-21T13:48:52.000Z","updated":"2021-04-30T08:39:21.000Z","comments":true,"path":"2020/05/21/JupyterHubAuth/","link":"","permalink":"https://orangecheers.top/2020/05/21/JupyterHubAuth/","excerpt":"默认JupyterHub是使用PAM, 与系统用户绑定的认证方式, 这使得JupyterHub的多用户非常不灵活,参见这个Issue: https://github.com/jupyterhub/jupyterhub/issues/710. JupyterHub默认支持了很多第三方的OAuth的认证渠道,但是这些大部分是在线的,不适合我的需求. 于是我在GitHub上找到了一个基于sqlite3数据库的离线认证器: https://github.com/sparkingarthur/jupyterhub-localsqliteauthenticator 按照Readme文件的步骤,安装成功后,在JupyterHub配置文件中将认证器修改为这个认证器:","text":"默认JupyterHub是使用PAM, 与系统用户绑定的认证方式, 这使得JupyterHub的多用户非常不灵活,参见这个Issue: https://github.com/jupyterhub/jupyterhub/issues/710. JupyterHub默认支持了很多第三方的OAuth的认证渠道,但是这些大部分是在线的,不适合我的需求. 于是我在GitHub上找到了一个基于sqlite3数据库的离线认证器: https://github.com/sparkingarthur/jupyterhub-localsqliteauthenticator 按照Readme文件的步骤,安装成功后,在JupyterHub配置文件中将认证器修改为这个认证器: 注意export修改环境变量并不是永久的,如果出现如下错误一般是环境变量出了问题,可以重新添加环境变量或者直接修改文件永久添加环境变量. 如果出现这样的问题,请使用sudo运行JupyterHub 登录第三方认证器自带的admin用户,登陆成功. 此时管理员面板中的的添加用户仍然是添加系统用户,并不是在我们的认证器中添加用户. 可以使用认证器提供的api来添加用户,右边就是这个认证器使用的数据库,默认是/etc/jupyterhub/jupyterhub-users.db 使用api添加用户后,会在数据库中生成记录,密码是用AES加密后存储的. 添加用户后,登陆成功.(注意如果不需要白名单功能应该在配置文件中将白名单配置删掉,否则不在白名单中的用户还是登陆不了) 邦邦pico沙雕小剧场更新了快去看","categories":[],"tags":[]},{"title":"VMware中Ubuntu 20.04下JupyterHub的安装与配置","slug":"JupyterHub","date":"2020-05-08T15:45:38.000Z","updated":"2021-04-30T08:39:29.000Z","comments":true,"path":"2020/05/08/JupyterHub/","link":"","permalink":"https://orangecheers.top/2020/05/08/JupyterHub/","excerpt":"昨天研究了一下JupyterHub的安装与配置,记录一下安装过程. 因为不想折腾双系统,也不太信任现在的WSL,选择了在VMware中运行Ubuntu. 1. 安装Ubuntu 20.04 前几天看到了Ubuntu的新LTS版本20.04出来了,一直想体验一把,正好趁这个机会看看长什么样. 镜像我直接在官网上下的,安装用VMware的简易安装就行了.注意虚拟机的网卡改成桥接模式,让虚拟机直接从路由器上获取ip,方便搭建好在主机上访问JupyterHub.装好Ubuntu后别忘了安装openssh和net-tools:","text":"昨天研究了一下JupyterHub的安装与配置,记录一下安装过程. 因为不想折腾双系统,也不太信任现在的WSL,选择了在VMware中运行Ubuntu. 1. 安装Ubuntu 20.04 前几天看到了Ubuntu的新LTS版本20.04出来了,一直想体验一把,正好趁这个机会看看长什么样. 镜像我直接在官网上下的,安装用VMware的简易安装就行了.注意虚拟机的网卡改成桥接模式,让虚拟机直接从路由器上获取ip,方便搭建好在主机上访问JupyterHub.装好Ubuntu后别忘了安装openssh和net-tools: sudo apt install openssh-server sudo apt install net-tools 安装成功后,在终端里使用ifconfig -a查看路由器分发的ip地址,在主机上使用ssh连接就可以搭建环境了. 2. 安装Anaconda3 去清华的镜像站(TUNA)上找到了Anaconda最新的包的地址:https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh, 使用wget下载到虚拟机中,然后执行安装脚本,按照他的指示来就行了. wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh sh ./Anaconda3-2020.02-Linux-x86_64.sh 默认是安装到~/anaconda3中. 顺便,这里我选择的是yes,我也不知道是干啥的. 执行 export PATH=~/anaconda3/bin:$PATH 将anaconda添加到PATH中. 输入conda,如果显示conda的提示,说明安装成功. 3.安装JupyterHub JupyterHub的官方文档(https://jupyterhub.readthedocs.io/en/stable/ )提供了两种安装方法: 这里选择第二种安装.注意如果使用第一种安装的话还需要先额外安装nodejs环境,官方给的命令是: sudo apt-get install npm nodejs-legacy 我使用 sudo apt install npm 也可以完成最终的安装. 还有一点就是conda的默认源在国外,如果没有特殊工具的话需要换源. 一般在网络终端上的工具都是不能实现完美的全局代理的,特别对于在虚拟机上的流量,即使使用Proxifier这样的东西也不能达到很好的效果.我是在路由器上直接使用了工具,所以没有考虑这一点.(不能再说了这网站备案了). 判断是否安装成功: jupyterhub -h configurable-http-proxy -h 运行jupyterhub: jupyterhub 出现此界面,安装成功. 下面进行用户的配置. 4.用户配置 使用 jupyterhub --generate-config 生成默认的jupyterhub配置文件. 官方文档建议将此文件放在/etc/jupyterhub目录下.可以自行创建此文件夹后在该文件夹下执行命令. 此时出现了一个棘手的问题: 我们没有权限在这个文件夹下进行写文件的操作. 一般遇到这样的情况都是直接sudo,但是当我执行 sudo jupyterhub --generate-config 他提示没有找到jupyterhub这个命令. 去网上搜索,找到了解决方法: 切换到root用户,编辑/etc/sudoers文件. 将其中Defaults env_reset这一行改成Defaults !env_reset 如果你没有为root用户设置过密码,应该先使用sudo passwd root来给root设置密码,然后使用su来切换到root账户. 如果没有安装vim,使用apt安装即可. 编辑好后,切换回刚刚的用户. 编辑/etc/bash.bashrc文件,向最后添加 alias sudo='sudo env PATH=$PATH' export PATH=~/anaconda3/bin:$PATH 如果出现文件无法保存,使用:wq!试试,还是不行直接sudo vim. 让修改的配置生效: source /etc/bash.bashrc 这时就可以在/etc/jupyterhub下执行 sudo jupyterhub --generate-config 还有一种方法,可以解决无法在此文件夹读写的问题,即使用 sudo chmod 777 /etc/jupyterhub 修改这个文件夹的权限,生成这个配置文件.但是到后期还是需要在sudo下运行jupyterhub,所以在现在直接解决这个问题就好了. 通过查阅官方文档,我们可以找到配置文件的基本配置. 按照官方文档的说法,默认的用户认证管理器是PAM,ubuntu系统上的用户都被允许登录. 所以我们可以先切换到root用户,在系统里添加一个用户: adduser kasumi 设置好密码后,返回原来的用户. 修改配置文件,将一个用户添加到管理员列表中(这里是honokasumi),另一个普通用户(这里是kasumi)添加到白名单中.(按照官方文档的说法,在管理员列表中的非白名单中的用户会被自动添加到白名单中): 指定配置文件,启动jupyter sudo jupyterhub -f /etc/jupyterhub/jupyterhub_config.py 访问http://ip:8000 ,输入账号密码,登录成功. 5.安装其他语言的内核 默认已经安装了Python3的内核,要想支持其他语言,需要安装其他语言的内核. 这里以安装C++系列内核为例. 使用 conda install xeus-cling -c conda-forge 安装xeus-cling,一个在jupyter上支持c++系列的内核. 安装成功后,可以在这里切换使用内核: https://github.com/jupyter/jupyter/wiki/Jupyter-kernels 这里列出了jupyter上其他语言的内核,可以自己寻找并安装.","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"Win10+CMake+MinGW+CLion环境配置","slug":"WCMC","date":"2020-03-27T13:56:00.000Z","updated":"2021-07-08T13:29:25.000Z","comments":true,"path":"2020/03/27/WCMC/","link":"","permalink":"https://orangecheers.top/2020/03/27/WCMC/","excerpt":"Win10+CMake+MinGW+CLion环境配置 在知乎上看到一篇简单介绍make,makefile,cmake的文章,原文链接https://zhuanlan.zhihu.com/p/111110992. 了解了这些东西之后,可以开始配置Windows上的C++环境了,这里使用CLion+MingW的配置. 首先在MinGW上下载mingw-get.exe. http://www.mingw.org/ 在mingw-get.exe所在目录下执行命令: .\\mingw-get.exe install gcc g++ gdb mingw32-make 安装gcc,g++,gdb以及mingw32-make,并将bin文件夹添加到PATH环境变量中. 安装CMake,在安装时可以勾选添加到PATH.","text":"Win10+CMake+MinGW+CLion环境配置 在知乎上看到一篇简单介绍make,makefile,cmake的文章,原文链接https://zhuanlan.zhihu.com/p/111110992. 了解了这些东西之后,可以开始配置Windows上的C++环境了,这里使用CLion+MingW的配置. 首先在MinGW上下载mingw-get.exe. http://www.mingw.org/ 在mingw-get.exe所在目录下执行命令: .\\mingw-get.exe install gcc g++ gdb mingw32-make 安装gcc,g++,gdb以及mingw32-make,并将bin文件夹添加到PATH环境变量中. 安装CMake,在安装时可以勾选添加到PATH. 为了进一步了解CMake,可以利用CMake在windows下的gui试验一下编译. 编写a.cpp和CMakeLists.txt文件,其中CMakeLists.txt文件内容为 #需要的最低cmake版本 CMAKE_MINIMUM_REQUIRED(VERSION 2.6) #项目名称 PROJECT(GGZKA) #把当前目录(.)下所有源代码文件和头文件加入变量SRC_LIST AUX_SOURCE_DIRECTORY(. SRC_LIST) #生成应用程序 hello (在windows下会自动生成hello.exe) ADD_EXECUTABLE(ggzka $&#123;SRC_LIST&#125;) 这就是一个最简单的CMakeLists.txt文件,足以将a.cpp编译成hello.exe. 打开CMake-gui,选择源码文件夹和二进制文件输出文件夹. 点Generate. 因为使用的是MinGW,所以选择MinGW Makefiles,也就是mingw32-make可以处理的makefiles文件. 要使用之前自己安装的MinGW,所以选择第二项,之后自己选择编译器. 选择好编译器后,正常的话已经可以在bin文件夹下生成Makefiles文件了,然后在bin文件夹下执行 mingw32-make 就可以看到bin文件夹下已经编译出hello.exe文件了. 懂得了基本概念之后,配置CLion也就很简单了. Environment选择MinGW所在的文件夹.Make选择mingw32-make,C编译器选择gcc,c++编译器g++即可.","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"CF-1326","slug":"CF-1326","date":"2020-03-23T06:28:30.000Z","updated":"2020-03-23T06:52:08.000Z","comments":true,"path":"2020/03/23/CF-1326/","link":"","permalink":"https://orangecheers.top/2020/03/23/CF-1326/","excerpt":"","text":"Codeforces Global Round 7 A. Bad Ugly Numbers n=1时,显然无解. n&gt;1时,第一位为2,后面全为3就是一个解. B. Maximums 递推. C. Permutation Partitions 最优答案肯定是让最大的k个数全部算上,让每个最大的k个数全部单独处在一个区间即可. D2. Prefix-Suffix Palindrome (Hard version) 先找到仅由长度相等的最长的前后缀构成的回文串,然后如果前缀之后或者后缀之前还有一个回文串,可以把这个回文串插入到中间,易知这样构造出的答案一定是最优的. 将字符串翻转一下再扫一遍就可以求出两边的回文串,然后去掉两边的回文串,在中间剩下的字符串跑一边马拉车,就可以找到前缀后最长的回文串,翻转一下再跑一边就可以找到后缀前最长的回文串,看哪个长加哪个就行了. 赛后题解没有用马拉车,用了一个神奇的方法求某位置开始的最长回文串,但是我没看懂.","categories":[{"name":"练习赛记录","slug":"练习赛记录","permalink":"https://orangecheers.top/categories/%E7%BB%83%E4%B9%A0%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"CF1325","slug":"CF-1325","date":"2020-03-14T16:18:02.000Z","updated":"2021-07-08T13:30:39.000Z","comments":true,"path":"2020/03/15/CF-1325/","link":"","permalink":"https://orangecheers.top/2020/03/15/CF-1325/","excerpt":"Codeforces Round #628 (Div. 2) Codeforces Round #628 (Div. 2) 比赛还有五十分钟才结束,但是后面那两道现在才不到30人过了的题对于我来说应该是不可做题,就先写总结了.(希望不会FST) A. EhAb AnD gCd 设g = gcd(a,b), 题目要求就是要找g + \\frac{a \\times b}{g} = x 让a=1,b=x-1即可. B. CopyCopyCopyCopyCopy 因为序列重复了n次,完全可以在每次重复中选序列中的一个数,这样就相当于可以不考虑顺序地选择数组成LIS,排个序后就是西电C语言期末考试真题.","text":"Codeforces Round #628 (Div. 2) Codeforces Round #628 (Div. 2) 比赛还有五十分钟才结束,但是后面那两道现在才不到30人过了的题对于我来说应该是不可做题,就先写总结了.(希望不会FST) A. EhAb AnD gCd 设g = gcd(a,b), 题目要求就是要找g + \\frac{a \\times b}{g} = x 让a=1,b=x-1即可. B. CopyCopyCopyCopyCopy 因为序列重复了n次,完全可以在每次重复中选序列中的一个数,这样就相当于可以不考虑顺序地选择数组成LIS,排个序后就是西电C语言期末考试真题. C. Ehab and Path-etic MEXs 只要能让0 1 2这三个数不在一条路径上,就能让这棵树的答案达到2. 并且,对于任意一棵树,答案最小是2,因为总可以找到一条路径包括0和1. 除了一条链的情况,其他的都可以通过先给叶子连的边填上0 1 2构造出答案. D. Ehab the Xorcist 异或和一定小于等于加和,这是因为异或和是\"不进位的加法\",异或和比加和少的部分就是本该进位的两位变成了0,所以当异或和&gt;加和或者两者差值为奇数时,无解. 答案不会超过3,这是因为可以构造这样一个数组:[a,a,b],其中a为两者差值的一半,b为满足加和条件的唯一b.这样通过异或,可以损失掉两个a,即两者的差值,并且不会影响到加和的结果. 因为每一位是独立的,如果a和b的1位不重叠,可以把他们压缩为一个数,即(a|b). (umi生日快乐!)","categories":[{"name":"练习赛记录","slug":"练习赛记录","permalink":"https://orangecheers.top/categories/%E7%BB%83%E4%B9%A0%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"2-SAT问题","slug":"2-SAT","date":"2020-03-10T17:22:19.000Z","updated":"2020-03-10T17:25:20.000Z","comments":true,"path":"2020/03/11/2-SAT/","link":"","permalink":"https://orangecheers.top/2020/03/11/2-SAT/","excerpt":"有N个变量,每个变量都能取T或F，需要满足M个条件: X_{i} = T or X_{j} = F 要给每个变量赋值,满足所有条件. 构造有向图G,每个X_{i}拆成两个点2i和2i+1, 分别表示X_{i}取T或者F. 每个变量选其中的一个进行标记,标记了节点2i表示X_{i}=T,标记2i+1表示X_{i}=F. 对于每个条件,如X_{i} = T or X_{j} = F,可以从表示点i为F的节点到表示点j为F的节点连一条边,表示如果点i为F,那么点j一定是F. 同时,还要从表示点j为T的点向表示点i为T的点连一条边. DFS方法","text":"有N个变量,每个变量都能取T或F，需要满足M个条件: X_{i} = T or X_{j} = F 要给每个变量赋值,满足所有条件. 构造有向图G,每个X_{i}拆成两个点2i和2i+1, 分别表示X_{i}取T或者F. 每个变量选其中的一个进行标记,标记了节点2i表示X_{i}=T,标记2i+1表示X_{i}=F. 对于每个条件,如X_{i} = T or X_{j} = F,可以从表示点i为F的节点到表示点j为F的节点连一条边,表示如果点i为F,那么点j一定是F. 同时,还要从表示点j为T的点向表示点i为T的点连一条边. DFS方法 逐个考虑每个未赋值的变量X_{i},先假定为真,标记结点2i,然后沿着边标记所有可以标记的点,并记录这个过程中标记了的点,方便更换这个变量的赋值.如果发现某个变量的两个点都被标记了,说明这个变量不可能为真,就要按照刚刚的记录,将标记去掉,清空记录,标记节点2i+1,重复过程.注意在假定为真的dfs之前也要清空记录. 如果这时候还不行,这个问题就无解,即使改变之前变量的值也没用. luogu P4782 模板 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #include &lt;set> #include &lt;algorithm> #define MAXN 1000005 #define INF 0x3f3f3f3f #define lovelive long long int #define osu(a,b,i) for(int i = (a);i &lt;= (b);i++) #define nso(a,b,i) for(int i = (a);i >= (b);i--) inline int homax(int a,int b) &#123; if(a > b) return a; return b; &#125; inline int homin(int a,int b) &#123; if(a > b) return b; return a; &#125; using namespace std; bool vis[MAXN*2]; vector&lt;int> sv; vector&lt;int> G[MAXN*2]; bool dfs(int x) &#123; if(vis[x^1]) return false; if(vis[x]) return true; vis[x] = true; sv.push_back(x); for(auto to : G[x]) &#123; if(!dfs(to)) return false; &#125; return true; &#125; void addcons(int x,int vx,int y,int vy) &#123; G[(x &lt;&lt; 1 | vx)^1].push_back(y &lt;&lt; 1 | vy); G[(y &lt;&lt; 1 | vy)^1].push_back(x &lt;&lt; 1 | vx); return ; &#125; int N,M; bool sat2() &#123; osu(1,N,i) &#123; if(vis[i &lt;&lt; 1] || vis[i &lt;&lt; 1 | 1]) continue; sv.clear();//假定为真的dfs之前清空记录 if(!dfs(i &lt;&lt; 1)) &#123; while(!sv.empty()) vis[sv.back()] = false, sv.pop_back(); if(!dfs(i &lt;&lt; 1 | 1)) &#123; return false; &#125; &#125; &#125; return true; &#125; int main() &#123; scanf(\"%d%d\",&amp;N,&amp;M); osu(1,M,i) &#123; int a,b,c,d; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d); addcons(a,b,c,d); &#125; if(sat2()) &#123; cout &lt;&lt; \"POSSIBLE\" &lt;&lt; endl; osu(1,N,i) &#123; if(vis[i &lt;&lt; 1]) &#123; cout &lt;&lt; 0 &lt;&lt; \" \"; &#125;else&#123; cout &lt;&lt; 1 &lt;&lt; \" \"; &#125; &#125; &#125;else&#123; cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; endl; &#125; return 0; &#125; 复杂度O(n(n+m)) 这个方法还可以保证答案的字典序,对于大部分的题目已经够用了. SCC方法 用Tarjan对每个SCC缩点,如果某个变量对应的两个节点在一个SCC中,则问题无解,否则一定有解. 如果一个变量的T结点所在SCC的拓扑序大于F结点的,那么就给这个变量赋T,否则赋F,用这个方法一定给所有有解的情况构造出答案. 复杂度O(n+m),达到了输入下限.但由于无法保证解的字典序,一般只用于判断是否有解. 例题 Now or later, UVA-1146 https://vjudge.net/problem/UVA-1146 题目大意 每个飞机都有2个降落时间,早降落时间和晚降落时间,每个飞机都可以选择早或者晚降落,每个飞机的早晚降落时间是固定的,但是可以和其他飞机不同. 你可以任意指定每个飞机的早晚降落情况,使每个飞机真正的降落时间之间的间隔最大. 解法 二分答案T,用A[x][0/1]代表第x个飞机的早降落时间和晚降落时间,如果|A[x_{1}][y_{1}] - A[x_{2}][y_{2}]| < P, 说明A[x_{1}][y_{1}]与A[x_{2}][y_{2}]不能同时选,即!(A[x_{1}][y_{1}] \\& A[x_{2}][y_{2}]), 由狄摩根定律,这个条件等价于A[x_{1}][!y_{1}] | A[x_{2}][!y_{2}],这就转化为了2-SAT判断有解性问题. https://vjudge.net/solution/24649633 #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #include &lt;set> #include &lt;algorithm> #define MAXN 2005 #define INF 0x3f3f3f3f #define lovelive long long int #define osu(a,b,i) for(int i = (a);i &lt;= (b);i++) #define nso(a,b,i) for(int i = (a);i >= (b);i--) inline int homax(int a,int b) &#123; if(a > b) return a; return b; &#125; inline int homin(int a,int b) &#123; if(a > b) return b; return a; &#125; inline int hoabs(int a) &#123; if(a > 0) return a; return -a; &#125; using namespace std; struct twosat&#123; int N; bool vis[MAXN*2]; vector&lt;int> sv; vector&lt;int> G[MAXN*2]; bool dfs(int x) &#123; if(vis[x^1]) return false; if(vis[x]) return true; vis[x] = true; sv.push_back(x); for(auto to : G[x]) &#123; if(!dfs(to)) return false; &#125; return true; &#125; void init() &#123; memset(vis,false,sizeof vis); sv.clear(); for(auto &amp;v : G) v.clear(); return ; &#125; void addcons(int x,int vx,int y,int vy) &#123; G[(x &lt;&lt; 1 | vx)^1].push_back(y &lt;&lt; 1 | vy); G[(y &lt;&lt; 1 | vy)^1].push_back(x &lt;&lt; 1 | vx); return ; &#125; bool sat2() &#123; osu(1,N,i) &#123; if(vis[i &lt;&lt; 1] || vis[i &lt;&lt; 1 | 1]) continue; sv.clear(); if(!dfs(i &lt;&lt; 1)) &#123; while(!sv.empty()) vis[sv.back()] = false, sv.pop_back(); if(!dfs(i &lt;&lt; 1 | 1)) &#123; return false; &#125; &#125; &#125; return true; &#125; &#125;ts; int N; int tb[MAXN][2]; bool judge(int x) &#123; ts.init(); ts.N = N; osu(1,N,i) osu(i+1,N,j) &#123; osu(0,1,k) osu(0,1,l) &#123; if(hoabs(tb[i][k] - tb[j][l]) &lt; x) &#123; ts.addcons(i,k^1,j,l^1); &#125; &#125; &#125; return ts.sat2(); &#125; int solve() &#123; int l = 0,r = 2e7; while(l &lt; r) &#123; int mid = ((l + r + 1) >> 1); if(judge(mid)) &#123; l = mid; &#125;else&#123; r = mid-1; &#125; &#125; return l; &#125; int main() &#123; while(~scanf(\"%d\",&amp;N)) &#123; memset(tb,0,sizeof tb); osu(1,N,i) &#123; osu(0,1,j) &#123; scanf(\"%d\",&amp;tb[i][j]); &#125; &#125; cout &lt;&lt; solve() &lt;&lt; endl; &#125; &#125; (明明UVALive-3211和UVA-1146是一样的题,但是在vjudge上一样的代码只能过UVA-1146...刚开始交UVALive-3211怎么都过不去,换了个一模一样的题交就过了,魔幻)","categories":[{"name":"算法","slug":"算法","permalink":"https://orangecheers.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://orangecheers.top/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://orangecheers.top/tags/2-SAT/"}]},{"title":"CF1305 (div1 + div2)","slug":"CF1305","date":"2020-03-08T13:47:43.000Z","updated":"2020-03-08T13:49:45.000Z","comments":true,"path":"2020/03/08/CF1305/","link":"","permalink":"https://orangecheers.top/2020/03/08/CF1305/","excerpt":"CF1305 (Div.1 + Div.2) Ozon Tech Challenge 2020 (Div.1 + Div.2, Rated, T-shirts + prizes!) A. Kuroni and the Gifts 排个序就行了","text":"CF1305 (Div.1 + Div.2) Ozon Tech Challenge 2020 (Div.1 + Div.2, Rated, T-shirts + prizes!) A. Kuroni and the Gifts 排个序就行了 B. Kuroni and Simple Strings 觉得应该和第三题换一下比较好. 为了求稳写了个模拟,从左往右每次扫到左括号的个数小于等于右括号的最后一个左括号时,就把前面的左括号和最后几个右括号同时删掉. 但是可以发现只用删一次,剩下的一定不是合法括号串. C. Kuroni and Impossible Calculation 坑比题,由抽屉原理可知N > M时一定有两个数字同余,直接输出0. N < Mn方暴力就行. D. Kuroni and the Celebration 交互题,第一次做,比赛时没敢开,其实很简单的. 每次选两个叶节点询问,如果这两个叶节点的lca是其中一个叶节点,那答案已经就是这个叶节点,否则删掉这连个点,继续询问. E. Kuroni and the Score Distribution 可以发现,对于固定的N,[1,2,...,N]是balance最多的序列,所以M&gt;这个序列的balance时一定是-1. 同时,从[1,2,...,N]到[1,2,...,N+1],balance多了\\lfloor \\frac{N}{2} \\rfloor. 可以先找出最大的N,使[1,...,N]的balance不大于M,用t代表这个序列的balance与M的差值,显然,这个t是小于\\lfloor \\frac{N}{2} \\rfloor的. 然后,输出这个序列倒数第一个(即N)与倒数第(2*t)个(即N-2\\times t+1)的和,这样就可以多出t对数与新输出的这个数组成一个合法对. 如果此时还剩下数没有输出,可以按照1e8+cnt\\times 1e4输出剩下的数,其中cnt代表剩下的第几个数.因为前面的数不会大于1e4,而cnt不会大于5e3,所以新输出的数不会超过2e8,这样就保证的新输出的这些数不会影响到这个序列的balance.","categories":[{"name":"练习赛记录","slug":"练习赛记录","permalink":"https://orangecheers.top/categories/%E7%BB%83%E4%B9%A0%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"CF-Round-#624-div3","slug":"CF-Round-624-div3","date":"2020-02-29T09:41:18.000Z","updated":"2020-03-06T14:54:46.000Z","comments":true,"path":"2020/02/29/CF-Round-624-div3/","link":"","permalink":"https://orangecheers.top/2020/02/29/CF-Round-624-div3/","excerpt":"CF Round #624 div.3 unrated,佛系比赛,不急不躁,不怒不争. A.Add Odd or Subtract Even 若 a > b ,且a-b为偶数,直接减去a-b即可,答案为1. 若 a > b ,且a-b为奇数,减去一个偶数再加上一个奇数,答案为2. 若 a < b ,且b-a为偶数,加上一个奇数再加上一个奇数,答案为2. 若 a > b ,且b-a为奇数,直接加上b-a即可,答案为1.","text":"CF Round #624 div.3 unrated,佛系比赛,不急不躁,不怒不争. A.Add Odd or Subtract Even 若 a > b ,且a-b为偶数,直接减去a-b即可,答案为1. 若 a > b ,且a-b为奇数,减去一个偶数再加上一个奇数,答案为2. 若 a < b ,且b-a为偶数,加上一个奇数再加上一个奇数,答案为2. 若 a > b ,且b-a为奇数,直接加上b-a即可,答案为1. B. WeirdSort 对每个可以相互交换的连续区间排序,最后判断是否单调不减即可. C. Perform the Combo 记录在每个位置断连的次数,扫字符串的同时更新答案即可. 最后要加一次全连. D. Three Integers 刚开始写的O(N\\sqrt N)算法： 枚举B,令A为离A最近的B的一个因数,C为离C最近的B的一个倍数,维护最优解即可. 找最近的因数只需枚举B的因数,与C最近的倍数一定是(C/B)*B,(C/B-1)*B,(C/B+1)*B之一. 把枚举上界设成15000可以卡过 题解是枚举A,然后枚举A的倍数作为B,然后确定C. 根据调和级数求和,可知该算法复杂度O(nlogn) E. Construct the Binary Tree 自然地想到可以从一条链的情况开始,每一次移动节点让答案减一. 不考虑非叶节点的移动一定不会让答案更坏,所以只考虑叶节点的移动. 因为移动是从下往上移动,所以如果先移动下方叶节点可能会在移动过程中被上方叶节点“挡住”,所以先考虑上方叶节点的移动. 因为初始是一条链,并且按从上到下编号依次增大的顺序排列,所以初始只有一个叶节点,编号为N. 用N个栈来维护第i层可以用来当作父节点的节点编号,如果一个节点为叶节点,那么他的编号将在对应的栈中出现两次,这样方便节点移动后更新栈的内容.使用栈来维护是因为这题没有对节点位置的要求,所以移动是只要是同一层的,选择哪个节点作为新的父节点都无所谓,并且入栈和出栈操作都是O(1). 移动时注意不仅要更新新父节点的那一层的栈的状态,还要更新父节点和自己本身那一层的栈的状态. 当一个叶节点无法继续移动时,由于初始是一条从上往下编号递增的链,所以如果这棵树还有可以移动的叶节点,那么他的编号一定是上一个叶节点编号-1.并且如果一个新的叶节点已经无法移动了,这棵树的答案就已经到了最小,如果此时的答案还未满足题目要求,那么题目的要求就不可能满足.方便写代码,可以当指定的叶节点的编号变为0时输出NO. 另外,题解给出了一种简单的方法判断题目的要求是否能满足：节点数固定时,这棵树答案最大的形态是一条链,最小的形态是一颗满二叉树,因为可以通过一个节点的上下移动来在这两个形态之间变换,所以这两种形态的答案之间的所有答案都能满足,在这之外的都不能满足. F. Moving Points 因为速度是常量,时间没有限制,所以两个点要么距离越来越小,最后相遇,要么距离越来越大或不变,永远不会相遇. 不失一般性地,考虑a_{i}和a_{j}两点,其中x_{i}>x_{j}.若v_{j} \\leqslant v_{i},这两点就永远不会相遇,d(i,j)为初始时两点的距离,即x_{i} - x_{j},否则两点一定会在某一时刻相遇,d(i,j)为0. 对于一个点a_{i},需要找到所有初始坐标小于这个点并且速度小于等于这个点的点,来a_{i}计算对答案的贡献. 这是一个二维偏序问题,不同的是为了计算贡献,我们不仅仅要计算满足这个条件的点的个数,同时也要计算满足这个条件的点的坐标之和.离散化之后使用两个树状数组,分别维护这两个信息即可.","categories":[{"name":"练习赛记录","slug":"练习赛记录","permalink":"https://orangecheers.top/categories/%E7%BB%83%E4%B9%A0%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"无向图割点/桥&双连通分量","slug":"无向图割点桥&双连通分量","date":"2020-02-29T09:41:18.000Z","updated":"2021-07-08T13:34:56.000Z","comments":true,"path":"2020/02/29/无向图割点桥&双连通分量/","link":"","permalink":"https://orangecheers.top/2020/02/29/%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E7%82%B9%E6%A1%A5&%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"无向图割点/桥&amp;双连通分量 无向图图中所有边要么是树边，要么是反向边。 割点的条件 当树根有两个及以上子节点时，树根是割点。 非根节点u为割点，当且仅当该点存在一个子节点v，且v及其所有后代都没有反向边连回u的祖先。（连回u不算，此时u是割点） 用LOW[x]代表x及其后代能连回祖先最小的DFN值，那么上述条件即为u存在一个子节点v，使得LOW[v] \\geqslant DFN[u]. 另外，若v的后代最早只能连到v自己，那么边(u,v)是桥。","text":"无向图割点/桥&amp;双连通分量 无向图图中所有边要么是树边，要么是反向边。 割点的条件 当树根有两个及以上子节点时，树根是割点。 非根节点u为割点，当且仅当该点存在一个子节点v，且v及其所有后代都没有反向边连回u的祖先。（连回u不算，此时u是割点） 用LOW[x]代表x及其后代能连回祖先最小的DFN值，那么上述条件即为u存在一个子节点v，使得LOW[v] \\geqslant DFN[u]. 另外，若v的后代最早只能连到v自己，那么边(u,v)是桥。 void tarjan(int x,int fa) &#123; DFN[x] = LOW[x] = ++xu; int cntz = 0; for(int i = 0;i &lt; G[x].size();i++) &#123; int to = G[x][i]; if(!DFN[to]) &#123; tarjan(to,fa); LOW[x] = homin(LOW[x],LOW[to]); if(LOW[to] >= DFN[x] &amp;&amp; x != fa) iscut[x] = 1;//此时G[x]为桥 if(x == fa) cntz++;//如果是根节点，计算子节点个数 &#125; LOW[x] = homin(LOW[x],DFN[to]); &#125; if(cntz >= 2) iscut[x] = 1;//根节点并且有两个及以上子节点 return ; &#125; 例题 POJ1523 给你一个联通网路，求出这个网络所有割点的编号，以及如果删除这个割点之后所对应的联通分量数. 求出所有割点后枚举要删除的割点然后dfs就行了. #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #include &lt;set> #include &lt;algorithm> #define MAXN 1050 #define INF 0x3f3f3f3f #define lovelive long long int inline int homax(int a,int b) &#123; if(a > b) return a; return b; &#125; inline int homin(int a,int b) &#123; if(a > b) return b; return a; &#125; using namespace std; vector&lt;int> G[MAXN]; int DFN[MAXN],LOW[MAXN],iscut[MAXN]; bool vis[MAXN]; int xu = 0; const int N = 1000; bool inp[MAXN]; void tarjan(int x,int fa) &#123; DFN[x] = LOW[x] = ++xu; int cntz = 0; for(int i = 0;i &lt; G[x].size();i++) &#123; int to = G[x][i]; if(!DFN[to]) &#123; tarjan(to,fa); LOW[x] = homin(LOW[x],LOW[to]); if(LOW[to] >= DFN[x] &amp;&amp; x != fa) iscut[x] = 1; if(x == fa) cntz++; &#125; LOW[x] = homin(LOW[x],DFN[to]); &#125; if(cntz >= 2) iscut[x] = 1; return ; &#125; void dfs(int x,int c) &#123; vis[x] = true; for(int i = 0;i &lt; G[x].size();i++) &#123; int to = G[x][i]; if(to == c || vis[to]) continue; dfs(to,c); &#125; return ; &#125; int main() &#123; int tt = 0; while(true) &#123; memset(inp,false,sizeof inp); for(int i = 0;i &lt; MAXN;i++) G[i].clear(); xu = 0; tt++; int a; scanf(\"%d\",&amp;a); if(a == 0) break; int b; scanf(\"%d\",&amp;b); G[a].push_back(b); G[b].push_back(a); inp[a] = inp[b] = true; while(true) &#123; int a; scanf(\"%d\",&amp;a); if(a == 0) break; int b; scanf(\"%d\",&amp;b); G[a].push_back(b); G[b].push_back(a); inp[a] = inp[b] = true; &#125; memset(DFN,0,sizeof DFN); memset(LOW,0,sizeof LOW); memset(iscut,0,sizeof iscut); for(int i = 1;i &lt;= N;i++) &#123; if(!inp[i]) continue; if(DFN[i] == 0) tarjan(i,i); &#125; printf(\"Network #%d\\n\",tt); bool tb = false; for(int i = 1;i &lt;= N;i++) &#123; if(!inp[i]) continue; if(iscut[i]) &#123; tb = true; memset(vis,false,sizeof vis); int cnt = 0; for(int j = 1;j &lt;= N;j++) &#123; if(!inp[j]) continue; if(vis[j] == false &amp;&amp; j != i) &#123; cnt ++; dfs(j,i); &#125; &#125; printf(\" SPF node %d leaves %d subnets\\n\",i,cnt); &#125; &#125; if(!tb) &#123; printf(\" No SPF nodes\\n\"); &#125; printf(\"\\n\"); &#125; &#125; 双连通分量 点双连通 点双连通(以下三条等价): 该连通图的任意两条边存在一个包含这两条边的简单环； 该连通图没有割点； 对于至少3个点的图，若任意两点有至少两条点不重复路径。 点双连通分量(BCC) 点双连通分量构成对所有边集的一个划分。(一个点可能属于多个点双连通分量,而一个边恰好属于一个) 两个点双连通分量最多只有一个公共点，且必为割点。进一步地，所有点双与割点可抽象为一棵树结构。 不同BCC可能会有公共点,最多只有一个,即割点.任意割点都至少属于两个BCC. 去掉BCC中任意一个点,BCC仍联通. 求每个点双分量的方法类似tarjan,栈存的不是点而是边,因为一个点可能属于多个点双,出栈之后无法将这个点统计到其他点双中,而每个边一定都只属于一个点双.不过这样的点一定是割点,可以用栈存点+对割点特判, 例题 HDU3884 无向图,在最少的点上安装太平井,使删除任意一个点后其他所有点都能到达太平井,并求出最少太平井的安装方案数. 点双缩点之后,整个图变成一个无根树. 考虑每个叶节点,在叶节点对应的点双中一定要有一个太平井,否则当删除对应的割点后,这个点双将无法到达任何太平井.并且,这个太平井不能安装在割点,如果安装在割点,删除割点后,这个点双的其他结点不仅无法到达其他叶节点的太平井,自己的太平井也被删了. 同时,对于每个非叶节点,是不需要太平井的.因为非叶节点度数大于1,只删除一个节点是无法让这个节点对应的点双的其他节点到达不了任意一个叶点双的. 缩点后每个节点的度数等于该点双中割点的个数,因为一个割点代表这个点双连接了另一个点双. 最终太平井的个数就是叶节点的个数,方案数就是每个叶节点对应的点双中非割节点的个数的乘积. 特别地,如果整个图只有一个点双,那么应该要修建两个太平井,防止删去唯一的太平井.此时方案数为N*(N-1)/2,其中N为节点个数. 代码:(https://vjudge.net/solution/24521411) #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #include &lt;set> #include &lt;algorithm> #include &lt;stack> #define MAXN 50005 #define INF 0x3f3f3f3f #define lovelive long long int #define osu(a,b,i) for(int i = (a);i &lt;= (b);i++) #define nso(a,b,i) for(int i = (a);i >= (b);i--) inline int homax(int a,int b) &#123; if(a > b) return a; return b; &#125; inline int homin(int a,int b) &#123; if(a > b) return b; return a; &#125; using namespace std; vector&lt;int> G[MAXN]; int DFN[MAXN],LOW[MAXN],iscut[MAXN]; int xu = 0; vector&lt;int> bcc[MAXN]; int bccno[MAXN]; int bcccnt = 0; stack&lt;pair&lt;int,int> > S; void tarjan(int x,int fa) &#123; DFN[x] = LOW[x] = ++xu; int cntz = 0; for(int i = 0;i &lt; G[x].size();i++) &#123; auto p = make_pair(x,G[x][i]); int to = G[x][i]; if(!DFN[to]) &#123; S.push(p); cntz++; tarjan(to,x); LOW[x] = homin(LOW[x],LOW[to]); if(LOW[to] >= DFN[x]) &#123; iscut[x] = 1; bcc[++bcccnt].clear(); while(true) &#123; auto e = S.top(); S.pop(); if(bccno[e.first] != bcccnt) bcc[bccno[e.first] = bcccnt].push_back(e.first); if(bccno[e.second] != bcccnt) bcc[bccno[e.second] = bcccnt].push_back(e.second); if(e.first == x &amp;&amp; e.second == G[x][i]) break; &#125; &#125; &#125;else if(DFN[to] &lt; DFN[x] &amp;&amp; to != fa) &#123; S.push(p); LOW[x] = homin(LOW[x],DFN[to]); &#125; &#125; if(fa &lt; 0 &amp;&amp; cntz &lt; 2) iscut[x] = 0; return ; &#125; int N,M; int main() &#123; scanf(\"%d\",&amp;M); int ttt = 0; while(M != 0) &#123; ttt++; N = 0; osu(0,MAXN-1,i) G[i].clear(),bcc[i].clear(); memset(DFN,0,sizeof DFN); memset(LOW,0,sizeof LOW); memset(iscut,0,sizeof iscut); xu = 0,bcccnt = 0; memset(bccno,0,sizeof bccno); osu(1,M,i) &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); N = homax(N,homax(a,b)); &#125; osu(1,N,i) &#123; if(!DFN[i]) tarjan(i,-1); &#125; lovelive ans1 = 0,ans2 = 1; osu(1,bcccnt,i) &#123; lovelive cnt = 0; osu(0,bcc[i].size()-1,j) &#123; if(iscut[bcc[i][j]]) cnt++; &#125; if(cnt == 1) &#123; ans1++; ans2 *= ((lovelive)bcc[i].size()-cnt); &#125; &#125; if(bcccnt == 1) &#123; ans1 = 2; ans2 = ((lovelive)bcc[1].size() * ((lovelive)bcc[1].size()-1))/2; &#125; printf(\"Case %d: %I64d %I64d\\n\",ttt,ans1,ans2); scanf(\"%d\",&amp;M); &#125; &#125; 边双连通 边双连通(以下三条等价): 该连通图的任意一条边存在一个包含这条边的简单环； 该连通图没有桥； 该连通图任意两点有至少两条(边不重复)路径。 边双连通分量(eBCC) 边双连通分量构成对所有点集的一个划分。 两个边双连通分量最多只有一条边，且必为桥。进一步地，所有边双与桥可抽象为一棵树结构。","categories":[{"name":"算法","slug":"算法","permalink":"https://orangecheers.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"算法总结","slug":"算法总结","permalink":"https://orangecheers.top/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"}]},{"title":"LSTM","slug":"LSTM","date":"2019-10-22T05:31:50.000Z","updated":"2020-03-06T17:03:57.000Z","comments":true,"path":"2019/10/22/LSTM/","link":"","permalink":"https://orangecheers.top/2019/10/22/LSTM/","excerpt":"LSTM","text":"LSTM import numpy import matplotlib.pyplot as plt from pandas import read_csv import math from keras.models import Sequential from keras.layers import Dense from keras.layers import LSTM from sklearn.preprocessing import MinMaxScaler from sklearn.metrics import mean_squared_error from keras import backend as K import os # load the dataset os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\" dataframe = read_csv('xian_tianqi.csv', usecols=[1], engine='python') import tensorflow as tf from keras.backend.tensorflow_backend import set_session config = tf.ConfigProto() config.gpu_options.allocator_type = 'BFC' #A \"Best-fit with coalescing\" algorithm, simplified from a version of dlmalloc. config.gpu_options.per_process_gpu_memory_fraction = 0.8 config.gpu_options.allow_growth = True set_session(tf.Session(config=config)) dataset = dataframe.values # 将整型变为float dataset = dataset.astype('float32') look_back = 1000 print(dataset[len(dataset)-look_back:(len(dataset)), 0]) # X is the number of passengers at a given time (t) and Y is the number of passengers at the next time (t + 1). # convert an array of values into a dataset matrix def create_dataset(dataset, look_back=1): dataX, dataY = [], [] for i in range(len(dataset)-look_back-1): a = dataset[i:(i+look_back), 0] dataX.append(a) dataY.append(dataset[i + look_back, 0]) return numpy.array(dataX), numpy.array(dataY) # fix random seed for reproducibility numpy.random.seed(7) # normalize the dataset scaler = MinMaxScaler(feature_range=(0, 1)) dataset = scaler.fit_transform(dataset) # split into train and test sets train_size = int(len(dataset)) train = dataset[0:train_size,:] # use this function to prepare the train and test datasets for modeling trainX , trainY= create_dataset(train, look_back) def XL(): # create and fit the LSTM network model = Sequential() model.add(LSTM(128, input_shape=(look_back,1))) model.add(Dense(1)) model.compile(loss='mae', optimizer='adam') model.fit(trainX, trainY, epochs=40, batch_size=256, verbose=2) return model ttr = trainX[trainX.shape[0]-1] tty = [] futu = 100 with open(\"tqyb.honoka\",\"w\") as f: f.write(\"2019/10/18\\r\\n\") for i in range(futu): trainX = numpy.reshape(trainX, (trainX.shape[0], look_back,1)) if(i % look_back == 0): model = XL() ttr = numpy.reshape(ttr,(1,look_back,1)) tty = model.predict(ttr) #print(trainX.shape[0],trainX.shape[1]) ttr = ttr[0][1:look_back].reshape(look_back-1).tolist() + tty[0].tolist() trainX = numpy.reshape(trainX, (trainX.shape[0], look_back)) trainX = numpy.vstack((trainX,ttr)) #print(tty,trainY) trainY = numpy.reshape(trainY, (trainY.shape[0], 1)) trainY = numpy.vstack((trainY,tty)) print(scaler.inverse_transform(tty)) f.write(\"i=\"+str(i) + \" \" + str(scaler.inverse_transform(tty)[0][0]) + '\\r\\n') #max(trainY.shape[0]-3*futu,0) plt.plot(scaler.inverse_transform(trainY[0:trainY.shape[0]]),color=\"#FDA423\") plt.plot(scaler.inverse_transform(trainY[0:trainY.shape[0]-futu]),color=\"#808080\",linestyle=\"--\") plt.savefig(\"op.png\") plt.show()","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"网络流常见方法汇总","slug":"网络流常见方法汇总","date":"2019-10-10T16:28:56.000Z","updated":"2020-03-06T15:12:24.000Z","comments":true,"path":"2019/10/11/网络流常见方法汇总/","link":"","permalink":"https://orangecheers.top/2019/10/11/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/","excerpt":"一年半前为了省选学网络流之后第一次做网络流的题 首先是自己改造后的Dinic:","text":"一年半前为了省选学网络流之后第一次做网络流的题 首先是自己改造后的Dinic: #include &lt;iostream> #include &lt;cstring> #include &lt;cstdio> #include &lt;queue> #include &lt;vector> #define INF 2147483647 #define MAXN 10005 #define MAXM 100005 using namespace std; struct addedge &#123; int to,flow,cap,ne; &#125;e[MAXM &lt;&lt; 1]; int head[MAXN]; int cur[MAXN]; int dep[MAXN]; int ecnt = -1; int N,M,S,T; void init() &#123; memset(head,-1,sizeof head); memset(dep,0,sizeof dep); return ; &#125; void addedge(int u,int v,int cap) &#123; e[++ecnt].to = v; e[ecnt].flow = 0; e[ecnt].cap = cap; e[ecnt].ne = head[u]; head[u] = ecnt; return ; &#125; queue&lt;int> q; int bfs() &#123; memset(dep,0,sizeof dep); dep[S] = 1; q.push(S); while(!q.empty()) &#123; int nown = q.front(); q.pop(); for(int i = head[nown];i != -1;i = e[i].ne) &#123; int to = e[i].to; if(dep[to] != 0 || e[i].flow >= e[i].cap) continue; dep[to] = dep[nown] + 1; q.push(to); &#125; &#125; return dep[T]; &#125; int homin(int a,int b) &#123; if(a &lt; b) return a; return b; &#125; int dfs(int x,int fl) &#123; if(x == T) return fl; for(int &amp;i = cur[x]; i != -1;i = e[i].ne) &#123; int to = e[i].to; if(dep[to] != dep[x] + 1 || e[i].flow >= e[i].cap) continue; int f = dfs(to,homin(fl,e[i].cap - e[i].flow)); if(f > 0) &#123; e[i].flow += f; e[i^1].flow -= f; return f; &#125; &#125; return 0; &#125; int Dinic() &#123; int ans = 0; while(bfs()) &#123; memcpy(cur,head,sizeof cur); while(int d = dfs(S,INF)) ans += d; &#125; return ans; &#125; void read(int &amp;ss) &#123; ss=0;char ch=getchar();while(ch&lt;'0'||ch>'9') ch=getchar(); while(ch>='0'&amp;&amp;ch&lt;='9') ss*=10,ss+=ch-'0',ch=getchar();return ; &#125; int main() &#123; init(); cin >> N >> M >> S >> T; for(int i = 0;i &lt; M;i++) &#123; int tu,tv,tw; cin >> tu >> tv >> tw; addedge(tu,tv,tw); addedge(tv,tu,0); &#125; cout &lt;&lt; Dinic() &lt;&lt; endl; &#125; 就用网络流24题当例题了 最大流 P2766 最长不下降子序列问题 第一问直接n^2就行,dp后的数组记为f,其中f[i]代表以第i个数结尾的最长不下降子序列的长度,答案记为ans1. a[i]代表第i个数. 第二问可以给对于每个 j #include &lt;cstring> #include &lt;cstdlib> #include &lt;vector> #include &lt;queue> #define INF 2147483647 #define MAXN 550 #define osu(a,b,i) for(int i = (a);i &lt;= (b);i++) #define nso(a,b,i) for(int i = (a);i >= (b);i--) #define lovelive long long int using namespace std; inline int homin(int a,int b) &#123; if(a > b) return b; return a; &#125; struct Edge&#123; int to,cap,flow,ne; &#125;; Edge e[MAXN &lt;&lt; 2]; Edge e2[MAXN &lt;&lt; 2]; int dep[MAXN &lt;&lt; 1]; int cur[MAXN &lt;&lt; 1]; int head[MAXN &lt;&lt; 1]; int ecnt = -1; int S,T; int N; int a[MAXN]; queue &lt;int> q; void init() &#123; memset(e,0,sizeof e); memset(head,-1,sizeof head); memset(dep,0,sizeof dep); &#125; int addedge(int u,int v) &#123; e[++ecnt].to = v; e[ecnt].cap = 1; e[ecnt].flow = 0; e[ecnt].ne = head[u]; head[u] = ecnt; e[++ecnt].to = u; e[ecnt].cap = 0; e[ecnt].flow = 0; e[ecnt].ne = head[v]; head[v] = ecnt; return ecnt - 1; &#125; int bfs() &#123; queue&lt;int> q2; swap(q,q2); memset(dep,0,sizeof dep); q.push(S); dep[S] = 1; //cout &lt;&lt; S &lt;&lt; \"dd\" &lt;&lt;q.front()&lt;&lt; endl; while(!q.empty()) &#123; int nown = q.front(); //cout &lt;&lt; nown &lt;&lt; \"&#125;\" &lt;&lt; endl; q.pop(); for(int i = head[nown];i!=-1;i = e[i].ne) &#123; //cout &lt;&lt; e[i].to &lt;&lt; \"gs\" &lt;&lt; dep[e[i].to]&lt;&lt;endl; int to = e[i].to; if(dep[to] != 0 || e[i].flow >= e[i].cap) continue; //cout &lt;&lt; \"!\" &lt;&lt; endl; dep[to] = dep[nown] + 1; q.push(to); &#125; &#125; return dep[T]; &#125; int dfs(int x,int fl) &#123; if(x == T) return fl; for(int &amp;i = cur[x];i != -1;i = e[i].ne) &#123; int to = e[i].to; if(dep[to] != dep[x]+1 || e[i].flow >= e[i].cap) continue; int f = dfs(to,homin(fl,e[i].cap - e[i].flow)); if(f > 0) &#123; e[i].flow += f; e[i^1].flow -= f; return f; &#125; &#125; return 0; &#125; int Dinic() &#123; int flow = 0; //cout &lt;&lt; \"!\" &lt;&lt; endl; while(bfs()) &#123; //cout &lt;&lt; \"!\" &lt;&lt; endl; memcpy(cur,head,sizeof cur); while(int d = dfs(S,INF)) flow += d; //cout &lt;&lt; \"?\" &lt;&lt; endl; &#125; return flow; &#125; int f[MAXN]; int fdp() &#123; int ans = -1; for(int i = 1;i &lt;= N;i++) &#123; int maxx = 0; for(int j = 1;j &lt; i;j++) &#123; if(f[j] > maxx &amp;&amp; a[j] &lt;= a[i]) &#123; maxx = f[j]; &#125; &#125; f[i] = maxx + 1; if(f[i] > ans) ans = f[i]; &#125; return ans; &#125; int main() &#123; init(); cin >> N; for(int i = 1;i &lt;= N;i++) &#123; cin >> a[i]; &#125; int ans1 = fdp(); S = 0;T = 2*N+1; int ea,eb,ec,ed; for(int i = 1;i &lt;= N;i++) &#123; if(i == 1) &#123; ec = addedge(2*i-1,2*i); &#125;else if(i == N) &#123; ed = addedge(2*i-1,2*i); &#125;else&#123; addedge(2*i-1,2*i); &#125; if(f[i] == 1) &#123; if(i == 1) &#123; ea = addedge(S,2*i-1); &#125;else&#123; addedge(S,2*i-1); &#125; &#125; if(f[i] == ans1) &#123; if(i == N) &#123; eb = addedge(2*i,T); &#125;else&#123; addedge(2*i,T); &#125; &#125; for(int j = 1;j &lt; i;j++) &#123; if(f[i] == f[j] + 1 &amp;&amp; a[i] >= a[j]) &#123; addedge(2*j,2*i-1); &#125; &#125; &#125; memcpy(e2,e,sizeof e); cout &lt;&lt; ans1 &lt;&lt; endl; cout &lt;&lt; Dinic() &lt;&lt; endl; cout &lt;&lt; ea &lt;&lt; \" \" &lt;&lt; eb &lt;&lt; \" \" &lt;&lt; ec &lt;&lt; \" \" &lt;&lt; ed &lt;&lt; endl; //cout &lt;&lt; \":1\" &lt;&lt; endl; memcpy(e,e2,sizeof e); //cout &lt;&lt; \":2\" &lt;&lt; endl; if(ea >= 0 &amp;&amp; ea &lt;= ecnt) e[ea].cap = INF; if(eb >= 0 &amp;&amp; eb &lt;= ecnt) e[eb].cap = INF; if(ec >= 0 &amp;&amp; ec &lt;= ecnt) e[ec].cap = INF; if(ed >= 0 &amp;&amp; ed &lt;= ecnt) e[ed].cap = INF; //cout &lt;&lt; \":3\" &lt;&lt; endl; if(N == 1) &#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; Dinic() &lt;&lt; endl; &#125; &#125; 最小割 P2774 方格取数问题 这道题也是一中\"并列\"的问题,要所有元素地位均相同,需要从中挑选出几个. \"割\"的概念是,让这个图的原点无法到达汇点,意味着关系的断绝. 将这个方格棋盘染色后,就是让黑点和其相邻的白点不能同时出现. 只要让建立的图反映出,当黑点和相邻的白点同时出现时,源点和汇点就会联通,这样让图不连通就意味着没有黑点和相邻白点同时出现. 为了让删去的点值最小,要把点值反映到边权上,才能利用\"最小\"割求解 #include &lt;iostream> #include &lt;cstring> #include &lt;cstdio> #include &lt;queue> #include &lt;vector> #define INF 2147483647 #define MAXN 10005 #define MAXM 100005 using namespace std; struct addedge &#123; int to,flow,cap,ne; &#125;e[MAXM &lt;&lt; 1]; int head[MAXN]; int cur[MAXN]; int dep[MAXN]; int ecnt = -1; int N,M,S,T; void init() &#123; memset(head,-1,sizeof head); memset(dep,0,sizeof dep); return ; &#125; void addedge(int u,int v,int cap) &#123; e[++ecnt].to = v; e[ecnt].flow = 0; e[ecnt].cap = cap; e[ecnt].ne = head[u]; head[u] = ecnt; return ; &#125; queue&lt;int> q; int bfs() &#123; memset(dep,0,sizeof dep); dep[S] = 1; q.push(S); while(!q.empty()) &#123; int nown = q.front(); q.pop(); for(int i = head[nown];i != -1;i = e[i].ne) &#123; int to = e[i].to; if(dep[to] != 0 || e[i].flow >= e[i].cap) continue; dep[to] = dep[nown] + 1; q.push(to); &#125; &#125; return dep[T]; &#125; int homin(int a,int b) &#123; if(a &lt; b) return a; return b; &#125; int dfs(int x,int fl) &#123; if(x == T) return fl; for(int &amp;i = cur[x]; i != -1;i = e[i].ne) &#123; int to = e[i].to; if(dep[to] != dep[x] + 1 || e[i].flow >= e[i].cap) continue; int f = dfs(to,homin(fl,e[i].cap - e[i].flow)); if(f > 0) &#123; e[i].flow += f; e[i^1].flow -= f; return f; &#125; &#125; return 0; &#125; int Dinic() &#123; int ans = 0; while(bfs()) &#123; memcpy(cur,head,sizeof cur); while(int d = dfs(S,INF)) ans += d; &#125; return ans; &#125; int a[105][105]; int main() &#123; init(); cin >> M >> N; S = N*M; T = N*M+1; int sum = 0; for(int i = 1;i &lt;= M;i++) &#123; for(int j = 1;j &lt;= N;j++) &#123; cin >> a[i][j]; sum += a[i][j]; &#125; &#125; for(int i = 1;i &lt;= M;i++) &#123; for(int j = 1;j &lt;= N;j++) &#123; int num = (i-1)*N + j-1; if((i+j) % 2 == 1) &#123; addedge(S,num,a[i][j]); addedge(num,S,0); if(i > 1) &#123; addedge(num,num-N,INF); addedge(num-N,num,0); &#125; if(i &lt; M) &#123; addedge(num,num+N,INF); addedge(num+N,num,0); &#125; if(j &lt; N) &#123; addedge(num,num+1,INF); addedge(num+1,num,0); &#125; if(j > 1) &#123; addedge(num,num-1,INF); addedge(num-1,num,0); &#125; &#125;else&#123; addedge(num,T,a[i][j]); addedge(T,num,0); &#125; &#125; &#125; cout &lt;&lt; sum - Dinic() &lt;&lt; endl; return 0; &#125; To be continued...","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"算法总结","slug":"算法总结","permalink":"https://orangecheers.top/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"网络流","slug":"网络流","permalink":"https://orangecheers.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"LZY的宇宙金牌之路","slug":"LZY的宇宙金牌之路","date":"2018-09-29T10:44:28.000Z","updated":"2020-03-06T15:00:08.000Z","comments":true,"path":"2018/09/29/LZY的宇宙金牌之路/","link":"","permalink":"https://orangecheers.top/2018/09/29/LZY%E7%9A%84%E5%AE%87%E5%AE%99%E9%87%91%E7%89%8C%E4%B9%8B%E8%B7%AF/","excerpt":"zhy出的b题","text":"zhy出的b题 题目背景 化学是一个神奇的学科，其中的分析化学方面的运算规则更是令人绝望。 LZY是一个五国金的选手，但是他想冲击世界乃至宇宙化学竞赛金奖是，遇到了一个简单的小问题——他突然忘记分析化学的有效数字修约规则了。没有它，LZY就没办法正确书写他的计算结果从而得到100分夺取金奖了。位居99.5分自然是LZY所不能容忍的。所以现在你快来帮他计算一下下面数据的应有结果吧！ 题目描述 数据有多组，均遵循修约规则。数据之间的运算为加合运算。数据范围为-100~100.小数位数均小于6位，所需输出的小数位数均小于4，输出值将被限定在一个合理范围，无需二次化简。 正经的修约规则（针对一个特定的结果进行位数的保留和舍去） 如果在要求位数之后的第一位（即平时所说的四舍五入部分）数字大于等于6或者小于等于4，那么直接进一或舍去 （四舍六入） 如果在要求位数之后的第一位是5.分为以下下列情况： 如果5不为小数部分最后一位，5之后的数不全为0，则进一。 如果5为小数部分最后一位，那么 如果5前面是奇数，则进一。 如果5前面是偶数，则舍去。 （奇进偶舍） 而对于多组数据，想判断那组数据最可靠（即误差最小），需要用到下列规则： 样本标准偏差的判断 对于一组数据（有n个数），保证n小于等于5 令其平均值为x0，这n个数分别为x1，x2,...,xn则 样本标准偏差 s越大，此组数据越不精确，本题最后的加合运算选用最精确的一组数据进行（即s最小的那个） 最后，在进行加合运算计算时，结果的有效数字时由各个加合数据决定的，这一个判断的依据为绝对误差。 运算结果的有效数字决定于这些数据中绝对误差的最大者。如 0.0121 25.64 1.05782相加。 其中，25.64为绝对误差的最大者（其绝对误差为正负0.01）（依最后一位数字计算），故按小数后保留2位报出结果 输入 见前，保留有效数字位数以上绝对误差确定。 共五组输入数据，第一个数为每组数据的数据个数，接下来为各组的数据。 输出 n组数据中，最精确的一组数据的所有数之和，再依绝对误差保留后的结果。","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"[p1311]选择客栈","slug":"p1311-选择客栈","date":"2018-08-04T14:09:37.000Z","updated":"2020-03-06T15:42:20.000Z","comments":true,"path":"2018/08/04/p1311-选择客栈/","link":"","permalink":"https://orangecheers.top/2018/08/04/p1311-%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88/","excerpt":"这题刚开始没想到可以枚举第二个客栈,选择了枚举第一个客栈. 因为只有一次询问,所以每个客栈最低消费的绝对值是没有意义的,有意义的只有这个客栈的最低消费与p的相对大小. 那么可以用1代表最低消费小于等于p,0代表大于p,对这个数组进行一次前缀和,那么这个前缀和就是一个具有单调性的数组. 这样枚举第一个客栈之后,可以用二分在logn时间内寻找出第一家可以喝咖啡的客栈,这家客栈之后的所有与第一家客栈色调相同的客栈都可以作为第二家客栈.","text":"这题刚开始没想到可以枚举第二个客栈,选择了枚举第一个客栈. 因为只有一次询问,所以每个客栈最低消费的绝对值是没有意义的,有意义的只有这个客栈的最低消费与p的相对大小. 那么可以用1代表最低消费小于等于p,0代表大于p,对这个数组进行一次前缀和,那么这个前缀和就是一个具有单调性的数组. 这样枚举第一个客栈之后,可以用二分在logn时间内寻找出第一家可以喝咖啡的客栈,这家客栈之后的所有与第一家客栈色调相同的客栈都可以作为第二家客栈. 可以预处理出每一家客栈之后每种色调的客栈有多少个. 小细节: 因为选择喝咖啡的客栈可以作为第一家或第二家客栈,所以在二分的时候寻找的不是前缀和为第一家客栈的前缀和+1的客栈,而是第一家客栈之前一家客栈的前缀和+1的客栈.即寻找的不是s[i]+1,而是s[i-1]+1. 还是因为选择喝咖啡的客栈可以作为第一家或第二家客栈,预处理每一家客栈之后的每种色调的客栈数量时要包括这家客栈.但是这样会导致计算两人住在同一家客栈的方案,所以在枚举第一家客栈时,计算出可以去哪喝咖啡后,如果可以喝咖啡的客栈与第一家客栈相同,方案数应-1. 放一下我巨丑的代码 #include &lt;iostream> #include &lt;cstring> #include &lt;cstdio> #include &lt;algorithm> #define MAXN 200005 #define osu(a,b,i) for(int i = a;i &lt;= b;i++) #define nso(a,b,i) for(int i = a;i >= b;i--) #define lovelive long long int using namespace std; int r[MAXN][55]; int sgn[MAXN]; int a[MAXN],s[MAXN]; int c[MAXN]; int N,K,P; int ts[MAXN]; int init() &#123; //sgn osu(1,N,i) &#123; if(a[i] &lt;= P)sgn[i] = 1; else sgn[i] = 0; &#125; //r memset(ts,0,sizeof ts); nso(N,1,i) &#123; ts[c[i]]++; osu(0,K-1,j) &#123; r[i][j] = ts[j]; &#125; &#125; //s osu(1,N,i) &#123; s[i] = s[i-1]+sgn[i]; &#125; &#125; inline void read(int &amp;ss) &#123; ss=0;char ch=getchar();while(ch>'9'||ch&lt;'0')ch=getchar(); while(ch>='0'&amp;&amp;ch&lt;='9')ss*=10,ss+=ch-'0',ch=getchar();return; &#125; int main() &#123; read(N);read(K);read(P); osu(1,N,i) &#123; read(c[i]);read(a[i]); &#125; init(); lovelive ans = 0; osu(1,N,i) &#123; int el=i,er=N; while(el &lt; er) &#123; int mid = ((el+er)>>1); if(s[mid] >= s[i-1] + 1) &#123; er = mid; &#125;else&#123; el = mid +1; &#125; &#125; lovelive tans = 0; if(s[el] &lt; s[i-1]+1)el = er; if(s[el] &lt; s[i-1]+1)continue; tans += r[el][c[i]]; if(el == i)tans--; ans += tans; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://orangecheers.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"二分","permalink":"https://orangecheers.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"nlogn最长不上升子序列","slug":"nlogn最长不上升子序列","date":"2018-04-05T14:21:49.000Z","updated":"2020-03-06T15:41:38.000Z","comments":true,"path":"2018/04/05/nlogn最长不上升子序列/","link":"","permalink":"https://orangecheers.top/2018/04/05/nlogn%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"nlogn的最长不上升子序列 nlogn的最长不上升子序列虽然不难,也很常用,但是很容易打错,一不注意就把变量名打错了. 主要思想是用二分优化\"寻找a[j]&gt;=a[i]中f[j]最大的j\" for(int i = 1;i &lt;= N;i++) &#123; int maxx = -INF; for(int j = 1;j &lt; i;j++)//优化这个循环 &#123; if(a[j] >= a[i])maxx = max(maxx,f[j]); &#125; f[i] = (maxx == INF)?1:maxx+1; &#125; 既然使用二分,就要寻找一个有单调性的东西.","text":"nlogn的最长不上升子序列 nlogn的最长不上升子序列虽然不难,也很常用,但是很容易打错,一不注意就把变量名打错了. 主要思想是用二分优化\"寻找a[j]&gt;=a[i]中f[j]最大的j\" for(int i = 1;i &lt;= N;i++) &#123; int maxx = -INF; for(int j = 1;j &lt; i;j++)//优化这个循环 &#123; if(a[j] >= a[i])maxx = max(maxx,f[j]); &#125; f[i] = (maxx == INF)?1:maxx+1; &#125; 既然使用二分,就要寻找一个有单调性的东西. 在原有的基础上新开一个数组temp[],temp[i]表示f[j] = i的最大的a[j],翻译成人话就是f值等于i的最大的数是多少. 因为是最长不上升子序列,所以在f值相同时,这个数越大越有价值. 可以发现这个temp是有单调性的,严格证明我不会,可以用反证法瞎搞搞证出来. 因为要找到一个最大的i,即f值,所以二分是要注意下一个小细节. 假如按照temp[1]到temp[N]这样从左到右写出来,我们要做的就是找出满足temp[k] &gt;= a[nown]的最右边的值 所以在二分时,如果当前二分的中点值等于a[nown],应当把左区间端点的值设置为mid,而不是mid+1,防止丢失解. 如果二分中点小于a[nown],可以大胆的将右端点设为mid-1 二分部分程序: int l,r; while(l + 1 &lt;= r) &#123; int mid = ((l+r)>>1); if(temp[l] >= a[nown]) &#123; l = mid; &#125;else&#123; r = mid-1; &#125; &#125; if(l &lt; r &amp;&amp; temp[r] >= a[nown])l = r; temp[l+1] = maxx(temp[l+1],a[nown]); 这样就实现了去掉f并优化时间复杂度到O(nlogn). 2018.4.5 22:20","categories":[],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://orangecheers.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"二分","permalink":"https://orangecheers.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://orangecheers.top/tags/dp/"}]},{"title":"[p3933]Chtholly-Nota-Seniorious","slug":"p3933-Chtholly-Nota-Seniorious","date":"2018-03-20T16:05:44.000Z","updated":"2021-07-10T07:41:24.000Z","comments":true,"path":"2018/03/21/p3933-Chtholly-Nota-Seniorious/","link":"","permalink":"https://orangecheers.top/2018/03/21/p3933-Chtholly-Nota-Seniorious/","excerpt":"P3933 Chtholly Nota Seniorious 题目背景 大样例下发链接: https://pan.baidu.com/s/1nuVpRS1 密码: sfxg こんなにも、たくさんの幸せをあの人に分けてもらった だから、きっと 今の、私は 谁が何と言おうと 世界一、幸せな女の子だ","text":"P3933 Chtholly Nota Seniorious 题目背景 大样例下发链接: https://pan.baidu.com/s/1nuVpRS1 密码: sfxg こんなにも、たくさんの幸せをあの人に分けてもらった だから、きっと 今の、私は 谁が何と言おうと 世界一、幸せな女の子だ 题目描述 ——“假如……我是说假如喔。 万一我再过五天就会死，你能不能对我温柔一点？” 巨大的六号兽五天后将袭击浮游大陆。 无数次计算得到的残酷数据表明，只有圣剑瑟尼欧尼斯的适格精灵——珂朵莉·诺塔·瑟尼欧尼斯(Chtholly Nota Seniorious)开启妖精乡之门，才可以以生命为代价守住浮游岛。 “至少，我也希望自己不用消失，也想让别人记住。我也想留下羁绊啊。” 留给妖精少女珂朵莉的时间似乎已经不多了。 年轻的二等技官，妖精仓库的管理员，世界上最后一个人类——威廉·克梅修，数百年前曾经是一名准勇者，掌握着成为一名勇者所需要的所有知识。 大战在即，调整圣剑的状态成为了一项重要的任务。 瑟尼欧里斯（セニオリス） 圣剑的其中之一，在现存的遗迹兵装中，拥有最强大的力量。 拥有非常特殊的资质，只有极少一部分的人才能使用。 由四十一个护符组成。能将所有事物包含不死者都回归「死亡」。 威廉需要调整圣剑的状态，因此他将瑟尼欧尼斯拆分护符，组成了一个nn 行mm 列的矩阵。 每一个护符都有自己的魔力值。现在为了测试圣剑，你需要将这些护符分成 A,B两部分。 要求如下： 圣剑的所有护符，恰好都属于两部分中的一部分。 每个部分内部的方块之间，可以通过上下左右相互到达，而且每个内部的方块之间互相到达，最多允许拐一次弯。 例如 ＡＡＡＡＡ ＡＡＡＡＡ ＡＡＡＡＡ ＡＡＢＡＡ ＢａＡＡＡ ＡＡＡＢＢ ＡＢＢＢＡ ＢＢＡＡＡ ＡＡＡＢＢ ＡＡＢＡＡ ＢａＡＡＡ ＡＢＢＢＢ ＡＡＡＡＡ ＡＡＡＡＡ ＢＢＢＢＢ (1) (2) (3) 其中(1)(2)是不允许的分法，(3)是允许的分法。在(2)中，a属于A区域，这两个a元素之间互相到达，没有办法最多只拐一次弯。 现在要问，所有合法的分法中，A区域的极差与B区域的极差 中间较大的一个的 最小值 是多少？ 好心而可爱的在一旁默默观察奈芙莲悄悄地告诉你，极差就是区域内最大值减去最小值。 夜晚的风吹拂着，68号岛上的景色竟与地上的森林无异。转念又想，黄金妖精本身就是与森林之中出现，成长，消亡的神秘存在啊。 时间不早了，早上训练中落败的珂朵莉即将回来了。您要尽快和威廉一起调整好圣剑，千万不能迟哟。 输入输出格式 输入格式： 第一行两个自然数n,m 接下来n 行，每行m 个自然数A_{i,j} 表示权值 输出格式： 一个整数表示答案。 输入输出样例 输入样例#1： 复制 4 4 1 12 6 11 11 4 2 14 10 1 9 20 4 17 13 10 输出样例#1： 复制 11 说明 样例解释 1 12 6 11 11 4 2 14 10 1 9 20 4 17 13 10 分法不唯一，如图是一种合法的分法。左边部分极差12-1=11，右边一块极差20-10=10，所以答案取这两个中较大者11。没有别的分法，可以使答案更小。 数据范围与约定 测试点 n m #1-2 ≤10 #3-4 1 ≤2000 #5-7 ≤200 #8-10 ≤2000 对于所有的权值1\\le A_{i,j} \\le 10^9 《末日时在做什么？有没有空？可以来拯救吗？》 看题比看番刺激系列 胡乱分析 翻译题意 最大的最小肯定是二分啊. 二分极值,然后check. 完 好下面考虑check怎么写. 先解释一下题目分割的要求. 根据题目描述,可以把要求抽象一下: 用一条折线,在图中将所有的AB分开,且分割线要么不拐弯,要么只能向一个方向拐弯. 这是一个不合法的情况,因为分割线在既背着第一列方向拐了又向着第一列方向拐了几次. 这是一个合法的情况,因为分割线从上到下看只向着第一列拐. 同样,旋转一下这条分割线也是合法的. 换一种说法,这条分割线除了两端,没有最上或最下或最左或最右. ＡＡＡＡＡ ＡＡＡＡＡ ＡＡＡＡＡ ＡＡＢＡＡ ＢａＡＡＡ ＡＡＡＢＢ ＡＢＢＢＡ ＢＢＡＡＡ ＡＡＡＢＢ ＡＡＢＡＡ ＢａＡＡＡ ＡＢＢＢＢ ＡＡＡＡＡ ＡＡＡＡＡ ＢＢＢＢＢ (1) (2) (3) 再根据这几个样例,基本题意就可以理解了吧. 基础的错误算法 刚开始拿到这题的时候,没什么思路的我准备瞎写个算法: 无视任何规则,从第一行第一列开始,按照从左到右,从上到下的方向以此考虑每个元素是否可以加入A集合,如果这个元素可以被加入A集合,更新目前已经选的元素组成的A集合的最大值和最小值,再考虑下一个元素.直到该元素不能加入A集合时,判断剩下的集合的极差是否在可接受的范围内. 很明显,这个方法有一个简单的反例. 1 1 1 6 -2 9 9 9 假如可以容忍的极差为5,这种方法考虑到6这个元素的时候,由于目前选的A集合的最小值为1,所以6加入A集合,但是此时最大值要更新为6; 但是当考虑到-2这个元素时,由于最大值已经被更新为6,-2是加入不到A集合的. 此时检查剩下的四个元素,极差为11,不能接受,好像并不存在一种分法能把极差降到5以下. 但是一眼可以看出,存在一种分法能把两个集合极差变为3和3(太显然了我不画了). 考虑为什么会错 重点就在那个6上,简单说,就是明明不该放到A集合的元素硬拉进来且更新了最大值最小值,导致应该在A集合的元素不能加入A集合. 换句话说在枚举过程中,在枚举完所有一定要加入A集合的元素之前枚举到了可以不加入A集合的元素,即枚举顺序错误 换一种枚举顺序? 考虑分割线的限制,再换一种说法: 为了方便,现在只讨论形如这样的分割线,即从上到下只向着第一列方向拐弯或不拐弯 想象每一行都有一个挡板,为这一行A与B集合的分界线,那么把这些挡板连起来就是整张图的分界线(看图). 为了保证合法,从上到下的挡板的位置必须不能比上一行挡板位置靠右. (为了方便,现在只讨论形如上图的分割线,即从上到下只背着第一列方向拐弯或不拐弯) 那么当两行挡板位置相等时,如果第一行挡板右边元素使可以接受的,那么就可以放心地把他加入A集合了. 因为此时由于第二行的挡板不能逾越第一行挡板的位置,如果第一行不动,他将不能再动,即使右边的元素可以接受. 即已经枚举完了一定要加入A集合的元素. 当然,当第二行右边的元素已经不可接受,第一行就可以不用等到第二行挡板和第一行一样时再移动. 考虑一个小问题 当遇到一个可以接受的元素k时,是否加入A集合,是否会因为加入A集合导致B集合出现问题? 当k为未加入元素的极值时,加入A集合就会缩小未来的B集合的极差. 当k不为未加入元素的极值时,加入A集合不会对B集合有任何影响. 算法实现 二分最小的可接受的极值上限,不断地从上到下,在保证从上到下的挡板的位置必须不能比上一行挡板位置靠右的条件下尝试移动该行的挡板. 为了保证下一行没有阻挡的情况下仅当两行挡板位置相同时才能延伸挡板,每次移动只能移动一格.(有点难说,这个意思自己理解一下稍微有点难). 当一行遇到阻碍时,因为每一次都只移动一格,该行之下的所有行要么已经被不可接受的元素阻挡,要么被这一行阻挡,所以下一次循环时就可以不用考虑改行之下的挡板. 当第一行遇到阻碍时,循环结束.统计剩下的元素组成的B集合的极值,如果可以接受,下调上限,否则 就可以返回false上调上限了?? 别忘了,这只是一种情况,一共8种情况呢.(四个延伸起始方向,两个拐弯方向) 这个可以通过旋转图像后再进行二分简单的实现,但是我当初敲代码的时候少了块脑子写了4个judge,给8种情况都写了一段来判断,反正过了也就不改了. 代码 #include &lt;iostream> #include &lt;cstdio> #define INF 2147483647 using namespace std; int a[2005][2005]; int s[2005]; int N,M; void _getnum(int &amp;xx) &#123; char tt=getchar(); while(tt&lt;'0'||tt>'9')tt=getchar(); for(xx=0;tt>='0'&amp;&amp;tt&lt;='9';tt=getchar())xx=xx*10+int(tt-'0'); &#125; int judge_1(int m) &#123; int minx = 1000000001,maxx = 0; while(1) &#123; bool t = 0; for(int i = 1;i &lt;= N;i++) &#123; if(s[i] &lt; s[i-1] &amp;&amp; s[i] &lt; M &amp;&amp; a[i][s[i]+1] - minx &lt;= m &amp;&amp; maxx - a[i][s[i]+1] &lt;= m) &#123; s[i]++; t = 1; if(a[i][s[i]] &lt; minx)minx = a[i][s[i]]; if(a[i][s[i]] > maxx)maxx = a[i][s[i]]; &#125; &#125; if(t == 0) &#123; break; &#125; &#125; minx = 1000000001,maxx = 0; for(int i = 1;i &lt;= N;i++) &#123; for(int j = s[i] + 1;j &lt;= M;j++) &#123; if(a[i][j] - minx > m || maxx - a[i][j] > m) &#123; return false; &#125; if(a[i][j] > maxx)maxx = a[i][j]; if(a[i][j] &lt; minx)minx = a[i][j]; &#125; &#125; return true; &#125; int judge_2(int m) &#123; int minx = 1000000001,maxx = 0; while(1) &#123; bool t = 0; for(int i = N;i >= 1;i--) &#123; if(s[i] &lt; s[i+1] &amp;&amp; s[i] &lt; M &amp;&amp; a[i][s[i]+1] - minx &lt;= m &amp;&amp; maxx - a[i][s[i]+1] &lt;= m) &#123; s[i]++; t = 1; if(a[i][s[i]] &lt; minx)minx = a[i][s[i]]; if(a[i][s[i]] > maxx)maxx = a[i][s[i]]; &#125; &#125; if(t == 0) &#123; break; &#125; &#125; minx = 1000000001,maxx = 0; for(int i = 1;i &lt;= N;i++) &#123; for(int j = s[i] + 1;j &lt;= M;j++) &#123; if((minx != INF &amp;&amp; maxx != -INF) &amp;&amp; (a[i][j] - minx > m || maxx - a[i][j] > m)) &#123; return false; &#125; if(a[i][j] > maxx)maxx = a[i][j]; if(a[i][j] &lt; minx)minx = a[i][j]; &#125; &#125; return true; &#125; int judge_3(int m) &#123; int minx = 1000000001,maxx = 0; //cout &lt;&lt; minx &lt;&lt; endl; while(1) &#123; bool t = 0; for(int i = M;i >= 1;i--) &#123; if(s[i] &lt; s[i+1] &amp;&amp; s[i] &lt; N &amp;&amp; a[s[i] + 1][i] - minx &lt;= m &amp;&amp; maxx - a[s[i] + 1][i] &lt;= m) &#123; s[i]++; t = 1; if(a[s[i]][i] &lt; minx)minx = a[s[i]][i]; if(a[s[i]][i] > maxx)maxx = a[s[i]][i]; &#125; &#125; if(t == 0) &#123; break; &#125; &#125; minx = 1000000001,maxx = 0; for(int i = 1;i &lt;= M;i++) &#123; for(int j = s[i] + 1;j &lt;= N;j++) &#123; if((minx != INF &amp;&amp; maxx != -INF) &amp;&amp; (a[j][i] - minx > m || maxx - a[j][i] > m)) &#123; return false; &#125; if(a[j][i] > maxx)maxx = a[j][i]; if(a[j][i] &lt; minx)minx = a[j][i]; &#125; &#125; return true; &#125; int judge_4(int m) &#123; int minx = 1000000001,maxx = 0; while(1) &#123; bool t = 0; for(int i = 1;i &lt;= M;i++) &#123; if(s[i] &lt; s[i-1] &amp;&amp; s[i] &lt; N &amp;&amp; a[s[i] + 1][i] - minx &lt;= m &amp;&amp; maxx - a[s[i] + 1][i] &lt;= m) &#123; s[i]++; t = 1; if(a[s[i]][i] &lt; minx)minx = a[s[i]][i]; if(a[s[i]][i] > maxx)maxx = a[s[i]][i]; &#125; &#125; if(t == 0) &#123; break; &#125; &#125; minx = 1000000001,maxx = 0; for(int i = 1;i &lt;= M;i++) &#123; for(int j = s[i] + 1;j &lt;= N;j++) &#123; if((a[j][i] - minx > m || maxx - a[j][i] > m)) &#123; return false; &#125; if(a[j][i] > maxx)maxx = a[j][i]; if(a[j][i] &lt; minx)minx = a[j][i]; &#125; &#125; return true; &#125; int judge(int m) &#123; for(int i = 0;i &lt; 2005;i++) &#123; s[i] = 0; &#125; s[0] = INF; if(judge_1(m))return true; for(int i = 0;i &lt; 2005;i++) &#123; s[i] = 0; &#125; s[N+1] = INF; if(judge_2(m))return true; for(int i = 0;i &lt; 2005;i++) &#123; s[i] = 0; &#125; s[M+1] = INF; if(judge_3(m))return true; for(int i = 0;i &lt; 2005;i++) &#123; s[i] = 0; &#125; s[0] = INF; if(judge_4(m))return true; return false; &#125; int main() &#123; _getnum(N); _getnum(M); for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;= M;j++) &#123; _getnum(a[i][j]); &#125; &#125; int l = 0,r = 1000000004; while(l+1 &lt; r) &#123; int mid = (l+r+1)/2; if(judge(mid)) &#123; r = mid; &#125;else&#123; l = mid; &#125; &#125; if(!judge(l)) l=r; printf(\"%d\",l); &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://orangecheers.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"二分","permalink":"https://orangecheers.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"[p4211]LNOI2014-LCA","slug":"p4211-LNOI2014-LCA","date":"2018-03-08T17:22:07.000Z","updated":"2020-03-06T15:42:44.000Z","comments":true,"path":"2018/03/09/p4211-LNOI2014-LCA/","link":"","permalink":"https://orangecheers.top/2018/03/09/p4211-LNOI2014-LCA/","excerpt":"LNOI2014 LCA 人生中第一道黑题 题目描述 给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。 设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。 有q次询问，每次询问给出l r z，求\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]","text":"LNOI2014 LCA 人生中第一道黑题 题目描述 给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。 设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。 有q次询问，每次询问给出l r z，求\\sum_{l \\leq i \\leq r}dep[LCA(i,z)] 输入输出格式 输入格式： 第一行2个整数n q。 接下来n-1行，分别表示点1到点n-1的父节点编号。 接下来q行，每行3个整数l r z。 输出格式： 输出q行，每行表示一个询问的答案。每个答案对201314取模输出 输入输出样例 输入样例#1： 5 2 0 0 1 1 1 4 3 1 4 2 输出样例#1： 8 5 说明 共5组数据，n与q的规模分别为10000,20000,30000,40000,50000。 显然暴力的复杂度是承受不了的,上来dfs肯定是不可行的. 首先考虑两个点的lca的深度的另外一中计算方法: 利用树剖+线段树把一个点到根节点的链上点权全部+1,深度即为另一点到根节点的链的点权之和 这个方法在直接求lca时显然是大材小用,200+行的代码只是为了求个lca的深度显然得不偿失. 但是这种方法在处理本题是很有用的方法,因为这种方法可以很方便的实现对区间求lca深度之和的操作. 如图,假如要求(红色点,橙色点)和棕色点的lca的深度之和,可以这样操作: (poadd(x,y),poque(x,y)分别为树剖中链增加,链查询函数) 1.poadd(R,0); &#x2F;&#x2F;这时poque(B,0)即为棕色点与红色点LCA的深度,即为2 2.poadd(Y,0); 3.poque(B,0);即为所求,即为3. 但是此时如果针对每一个操作都在线计算的话,复杂度仍不能达到要求. 这时注意到如果按顺序进行poadd(i,0)的操作,所有区间所需的数据都已经计算出来,即考虑差分. 采用离线算法,将所有查询全部读入后,在l-1和r处分别打上起始标记和结束标记,然后按顺序执行poadd(i,0)的操作,若发现有标记,则在对应该查询的数组存此时poque(z,0)的值,为了差分,起始和结束可以分开记录. 这是差分部分的代码,利用vector来给每一个点记录标记,用st[i],ed[i]表示第i次查询的差分起始数据和差分终止数据. for(int i = 0;i &lt; N;i++) &#123; poadd(0,i); for(int j = 0;j &lt; stb[i].size();j++) &#123; st[stb[i][j]] = poque(0,z[stb[i][j]]); &#125; for(int j = 0;j &lt; edb[i].size();j++) &#123; ed[edb[i][j]] = poque(0,z[edb[i][j]]); &#125; &#125; 最后输出每一次查询ed[i]-st[i]即可. 本来一中午一个多小时就写完了代码,但是因为我太弱了,复制了lzydalao少了一个=的读入优化,三天没改出来...(还是我太弱了) 知道明明输出q行却一直提示Too Many or Too few Lines有多么抑郁吗,特别是在各种环境测试都没错的时候. 究其根本原因还是我太弱了 完整代码: #include &lt;iostream> #include &lt;cstdio> #include &lt;cstring> #include &lt;vector> #define lson (o &lt;&lt; 1) #define rson (o &lt;&lt; 1|1) #define mid ((l+r)>>1) #define MAXN 50005 #define m 201314 using namespace std; int fa[MAXN],son[MAXN],siz[MAXN]; int l[MAXN],dep[MAXN],top[MAXN]; vector&lt;int> stb[MAXN],edb[MAXN]; int st[MAXN],ed[MAXN]; int N,M,R; int z[MAXN]; struct Edge&#123; int to,ne; &#125;e[MAXN *2]; struct Segtree &#123; int val,lazy; &#125;tree[MAXN*4]; int head[MAXN]; int ecnt = 0; void addedge(int x,int y) &#123; e[++ecnt].to = y; e[ecnt].ne = head[x]; head[x] = ecnt; return; &#125; void pushdown(int l,int r,int o) &#123; tree[lson].val += (mid-l+1)*tree[o].lazy%m; tree[lson].lazy += tree[o].lazy%m; tree[rson].val += (r-mid)*tree[o].lazy%m; tree[rson].lazy += tree[o].lazy%m; tree[o].lazy = 0; return; &#125; void update(int ql,int qr,int l,int r,int o) &#123; if(ql > r || qr &lt;l) &#123; return; &#125; if(ql &lt;= l &amp;&amp; qr >= r) &#123; tree[o].lazy += 1; tree[o].val += (r-l+1); return; &#125; pushdown(l,r,o); update(ql,qr,l,mid,lson); update(ql,qr,mid+1,r,rson); tree[o].val = (tree[lson].val%m + tree[rson].val%m)%m; return; &#125; int query(int ql,int qr,int l,int r,int o) &#123; if(ql > r || qr &lt; l) &#123; return 0; &#125; if(qr >= r &amp;&amp; ql &lt;= l) &#123; return tree[o].val; &#125; pushdown(l,r,o); return (query(ql,qr,l,mid,lson)%m + query(ql,qr,mid+1,r,rson)%m)%m; &#125; void dfs1(int x) &#123; siz[x] = 1; for(int i = head[x];i;i=e[i].ne) &#123; int to = e[i].to; if(to == fa[x]) &#123; continue; &#125; if(son[x] = -1)son[x] = to; else if(siz[to] > siz[son[x]]) &#123; son[x] = to; &#125; fa[to] = x; dep[to] = dep[x]+1; dfs1(to); siz[x] +=siz[to]; &#125; return; &#125; int xu = 0; void dfs2(int x,int ttop) &#123; //cout &lt;&lt; x &lt;&lt; endl; l[x] = ++xu; top[x] = ttop; if(son[x] != -1) dfs2(son[x],ttop); for(int i = head[x];i;i = e[i].ne) &#123; int to = e[i].to; if(to == son[x] || to == fa[x]) &#123; continue; &#125; dfs2(to,to); &#125; return; &#125; inline void mswap(int &amp;a,int &amp;b) &#123; int t = a; a = b; b = t; return; &#125; void poadd(int x,int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) &#123; mswap(x,y); &#125; update(l[top[x]],l[x],1,N,1); x = fa[top[x]]; &#125; if(dep[x] &lt; dep[y]) &#123; mswap(x,y); &#125; update(l[y],l[x],1,N,1); return; &#125; int poque(int x,int y) &#123; int ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) &#123; mswap(x,y); &#125; ans += query(l[top[x]],l[x],1,N,1); ans = ans%m; x = fa[top[x]]; &#125; if(dep[x] &lt; dep[y]) &#123; mswap(x,y); &#125; ans += query(l[y],l[x],1,N,1); ans %= m; return ans; &#125; void read(int &amp;s) &#123; s=0;char ch=getchar(); while(ch&lt;'0'||ch>'9')ch=getchar(); while(ch>='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return; &#125; int fm(int a) &#123; int s = a; while(s&lt;0)s+=m; return s; &#125; int main() &#123; //freopen(\"4211.in\",\"r\",stdin); memset(siz,0,sizeof(siz)); memset(top,-1,sizeof(top)); memset(son,-1,sizeof(son)); memset(l,0,sizeof(l)); memset(dep,0,sizeof(dep)); memset(fa,-1,sizeof(fa)); read(N);read(M); R = 0; for(int i = 1;i &lt;= N-1;i++) &#123; int ed; read(ed); addedge(i,ed); addedge(ed,i); &#125; for(int i = 0;i &lt; M;i++) &#123; int op,ed; read(op); read(ed); read(z[i]); stb[op-1].push_back(i); edb[ed].push_back(i); &#125; dfs1(R); //cout &lt;&lt; \"1!\" &lt;&lt; endl; dfs2(R,R); //cout &lt;&lt; \"2!\" &lt;&lt; endl; for(int i = 0;i &lt; N;i++) &#123; poadd(0,i); for(int j = 0;j &lt; stb[i].size();j++) &#123; st[stb[i][j]] = poque(0,z[stb[i][j]]); &#125; for(int j = 0;j &lt; edb[i].size();j++) &#123; ed[edb[i][j]] = poque(0,z[edb[i][j]]); &#125; &#125; for(int i = 0;i &lt; M-1;i++) &#123; printf(\"%d\\n\",fm(ed[i]-st[i])); &#125; printf(\"%d\",fm(ed[M-1]-st[M-1])); //cout &lt;&lt; poque(0,4); &#125; 2018-3-9 0:31:37 AC 2018-3-9 1:20:30 我要猝死了.","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://orangecheers.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"询问差分","slug":"询问差分","permalink":"https://orangecheers.top/tags/%E8%AF%A2%E9%97%AE%E5%B7%AE%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://orangecheers.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"贪心-分治-分块总结","slug":"贪心-分治-分块总结","date":"2018-03-01T15:12:44.000Z","updated":"2021-04-30T08:35:10.000Z","comments":true,"path":"2018/03/01/贪心-分治-分块总结/","link":"","permalink":"https://orangecheers.top/2018/03/01/%E8%B4%AA%E5%BF%83-%E5%88%86%E6%B2%BB-%E5%88%86%E5%9D%97%E6%80%BB%E7%BB%93/","excerpt":"基础算法 贪心 根据贪心的数学背景我们在做贪心题目的时候一般有两种策略： 1.把一个问题划分成很多子问题，对于每个子问题直接求最优解，然后合成一个最优解； 2.对于当前局面，搜索所有可能的“临近局面”，选择最优的局面进行转移","text":"基础算法 贪心 根据贪心的数学背景我们在做贪心题目的时候一般有两种策略： 1.把一个问题划分成很多子问题，对于每个子问题直接求最优解，然后合成一个最优解； 2.对于当前局面，搜索所有可能的“临近局面”，选择最优的局面进行转移 数据范围较大时，一般使用贪心 贪心的复杂度一般很小 eg1. 按单价排序即可 eg2. (https://imgchr.com/i/9rw1gI) 数学上的mod指如果mod为负数,不断加模数直到为正数. 即 '5 mod 6 = 5' eg3-4 紫书区间问题 eg5. 非矩形贪心问题一定要转化成线段问题 雷达放在x轴上一定比放在x轴下方更优 错误思路 从左到右考虑所有岛,在能探测到一个岛的前提下,尽可能的向右放 由于圆的特性,会出现以下反例 正确思路 考虑到圆的复杂,应转化为线段贪心问题. 改变研究对象 考虑研究每一个岛屿. 由于雷达的半径固定,所以对于每一个与x轴距离小于半径的岛屿,都能在x轴上找到一个区间,使这个区间里所有的雷达都能探测到这个岛屿. 问题转化为区间选点问题. eg6. 进制问题 因为1!+2!+...+(n-1)! &lt; n! 所以如果可以表示,则一定可以通过每次取最大的不超过n-已表示的数的数的阶乘得到 [一个我不知道为什么的结论] eg7. 字典序最大即越靠前越大 当K&lt;= N-1时,把第N个数换到最前 K&gt;N-1时类似. eg8. 过于复杂先挖个坑 贪心的骗分策略 1.贪心算法与随机化算法的结合（例如模拟退火） 在决策时有概率接受比当前情况差的方向 在搜索到结果时以一定概率跳出当前解，重新开始贪心 在贪心开始的时候，利用随机化选择多个起点开始贪心，取其最小值 可以在最外层循环1000次随机起点来贪心,在数据范围小时极为有效 分治 分治的用处 分治算法在OI中的运用主要在两个方面： 基于二分查找、三分查找的运用 将题目划分为更细小的子问题的运用 二分 本质:在一个范围里确定一个分界,使分界的左边满足一个条件,右边满足一个条件 适用范围:范围满足单调性 常见使用情景: 简单的二分查找 在一个单调函数里寻找可行最值 最值的最值 首先我们需要一个好的模板 while(l + 1 &lt; r) &#123; int mid = (l + r + 1) >> 1; if(judge(mid)) &#123; r = mid; &#125;else&#123; l = mid; &#125; &#125; if(!judge(l))l = r; //by Chtholly eg1. 借教室的原则是先到先得 这句话点明修改的订单编号满足单调性.即如果前面的订单都满足不了,后面的订单一定不能满足.如果后面的订单可以满足,前面的订单一定能满足. 主题框架 既然满足单调性,不难想到二分.二分出能满足的订单与不能满足的订单的分界即可. 数据结构 显然这道题多次进行区间修改,单点查询 的操作,考虑用差分来维护. eg2. 有一个序列&#123;Ai&#125;以及m个区间[li..ri] 你现在可以选择k个区间，对于每个被选中的区间[l..r]，Al~Ar的数都会增加delta 求在所有方案中a中最小值最大为多少 二分 + 一些神奇的算法 这个神奇的算法能计算出能否选中k个区间使任意一个点仍保持在k以下 二分出k的最大值即可 具体使什么神奇的算法我好像忘了但好像是贪心 eg3. 过于复杂先开个坑 三分 使用范围:求一个单峰函数的最值 ppt好像有错误不确定就不写了 归并类分治 分块!!!!! 类型 给出一个长度为n的数列，以及m个操作，支持区间加法，单点查询 给出一个长为n的数列以及m个操作，支持区间加法，并询问区间内小于等于某个数x的元素个数 给出一个长为n的数列以及m个操作，支持区间开方，区间求和 分块 分块是线段树/树状数组的一个替代品. 给定一个区间,分为[sqrt(N)]块,每一块有[sqrt(N)]个元素. 剩余的不足[sqrt(N)]个元素单独暴力处理. []为向下取整 区间加法,单点查询 类lazy标记 每一块都有一个lazy标记. 加法区间内的整块加法,只需在加lazy标记上加. 查询时加上该块的标记即可. 不在整块内的?暴力啊啊啊啊! 区间加法,查询小于x的个数 每一块排序+二分 不解释 不在整块内的同样暴力啊啊啊 区间开方,区间求和 因为是向下取整开方,所以每一数在开方后多次后就会变为1 然后自己研究吧(狗屎) eg1. 难点主要在如何求[l,r]之间不同的元素 用pre[i]代表上一次出现a[i]这个元素的位置,问题转化为查询[l,r]区间内pre[i] &lt; l的个数. O(n)即可完成预处理 2018-2-16","categories":[{"name":"算法","slug":"算法","permalink":"https://orangecheers.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://orangecheers.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"https://orangecheers.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"分块","slug":"分块","permalink":"https://orangecheers.top/tags/%E5%88%86%E5%9D%97/"},{"name":"分治","slug":"分治","permalink":"https://orangecheers.top/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"[p1073]最优贸易","slug":"p1073-最优贸易","date":"2018-01-13T09:45:53.000Z","updated":"2020-03-06T15:42:09.000Z","comments":true,"path":"2018/01/13/p1073-最优贸易/","link":"","permalink":"https://orangecheers.top/2018/01/13/p1073-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/","excerpt":"题目描述 C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。","text":"题目描述 C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。 阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在 2 号城市以 3 的价格买入水晶球，在 3号城市以 5 的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。 现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入输出格式 输入格式： 第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。 接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。 输出格式： 输出文件 trade.out 共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。 输入输出样例 输入样例#1： 5 5 4 3 5 6 1 1 2 1 1 4 1 2 3 2 3 5 1 4 5 2 输出样例#1： 5 说明 数据范围 输入数据保证 1 号城市可以到达 n 号城市。 对于 10%的数据，1≤n≤6。 对于 30%的数据，1≤n≤100。 对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。 对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市 水晶球价格≤100。 NOIP 2009 提高组 第三题 分析 解法1：tarjan缩点+dp 解法2：分层图思想 【图源题解】","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"分层图","slug":"分层图","permalink":"https://orangecheers.top/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"},{"name":"巧妙的解法","slug":"巧妙的解法","permalink":"https://orangecheers.top/tags/%E5%B7%A7%E5%A6%99%E7%9A%84%E8%A7%A3%E6%B3%95/"}]},{"title":"[p1027]Car的旅行路线","slug":"p1027-Car的旅行路线","date":"2018-01-10T08:55:24.000Z","updated":"2020-03-06T15:42:01.000Z","comments":true,"path":"2018/01/10/p1027-Car的旅行路线/","link":"","permalink":"https://orangecheers.top/2018/01/10/p1027-Car%E7%9A%84%E6%97%85%E8%A1%8C%E8%B7%AF%E7%BA%BF/","excerpt":"P1027 Car的旅行路线 题目描述 又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。","text":"P1027 Car的旅行路线 题目描述 又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。 图例（从上而下） 机场 高速铁路 飞机航线 注意：图中并没有标出所有的铁路与航线。 那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。 找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。 输入输出格式 输入格式： 第一行为一个正整数n(0&lt;=n&lt;=10)，表示有n组测试数据。 每组的第一行有四个正整数s，t，A，B。 S(0&lt;S&lt;=100)表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号，(1&lt;=A，B&lt;=S)。 接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T I为第I个城市高速铁路单位里程的价格。 输出格式： 共有n行，每行一个数据对应测试数据。 保留一位小数 输入输出样例 输入样例#1： 1 3 10 1 3 1 1 1 3 3 1 30 2 5 7 4 5 2 1 8 6 8 8 11 6 3 输出样例#1： 47.5 #分析 ####披着蓝皮的大水题 每一个机场看作一个节点，所有道路和航线看成边，边权为距离×价格，跑一遍floyd后，枚举起点城市终点城市的所有机场判断最小价格即可。 #include #include &lt;cmath> #include &lt;cstdio> #define INF 999999999 using namespace std; int nce = 0; int ncity,op,ed; double fp; double ans = INF; struct City&#123; double ft; double x[4]; double y[4]; &#125;c [105]; double e[105][4][105][4]; double mymin(double a,double b) &#123; if(a &lt; b) &#123; return a; &#125; return b; &#125; double d(double x1,double y1,double x2,double y2) &#123; return sqrt((x2-x1) * (x2-x1) + (y2-y1) * (y2-y1)); &#125; bool is90(double x1,double y1,double x2,double y2,double x3,double y3) &#123; if((x2-x1) * (x3-x2) + (y2-y1) * (y3-y2) == 0) &#123; return true; &#125; return false; &#125; int main() &#123; cin >> nce; for(int ncc = 0;ncc &lt; nce;ncc++) &#123; for(int i = 0;i &lt; 105;i++) &#123; for(int j = 0;j &lt; 4;j++) &#123; for(int k = 0;k &lt; 105;k++) &#123; for(int l = 0;l &lt; 4;l++) &#123; e[i][j][k][l] = INF; &#125; &#125; &#125; &#125; cin >> ncity >> fp >> op >> ed; for(int i = 0;i &lt; ncity;i++) &#123; for(int j = 0;j &lt; 3;j++) &#123; cin >> c[i].x[j] >> c[i].y[j]; &#125; cin >> c[i].ft; &#125; //get the forth point (Vector) for(int i = 0;i &lt; ncity;i++) &#123; double midx,midy; if(is90(c[i].x[0],c[i].y[0],c[i].x[1],c[i].y[1],c[i].x[2],c[i].y[2])) &#123; midx = (c[i].x[0] + c[i].x[2]) / 2; midy = (c[i].y[0] + c[i].y[2]) / 2; c[i].x[3] = 2*midx - c[i].x[1]; c[i].y[3] = 2*midy - c[i].y[1]; &#125;else if(is90(c[i].x[1],c[i].y[1],c[i].x[0],c[i].y[0],c[i].x[2],c[i].y[2])) &#123; midx = (c[i].x[1] + c[i].x[2]) / 2; midy = (c[i].y[1] + c[i].y[2]) / 2; c[i].x[3] = 2*midx - c[i].x[0]; c[i].y[3] = 2*midy - c[i].y[0]; &#125;else if(is90(c[i].x[0],c[i].y[0],c[i].x[2],c[i].y[2],c[i].x[1],c[i].y[1])) &#123; midx = (c[i].x[0] + c[i].x[1]) / 2; midy = (c[i].y[0] + c[i].y[1]) / 2; c[i].x[3] = 2*midx - c[i].x[2]; c[i].y[3] = 2*midy - c[i].y[2]; &#125; //cout &lt;&lt; c[i].x[3] &lt;&lt; \" \" &lt;&lt; c[i].y[3] &lt;&lt; endl; &#125; //init for(int ic = 0;ic &lt; ncity;ic++) &#123; for(int ip = 0;ip &lt; 4;ip++) &#123; for(int jc = 0;jc &lt; ncity;jc++) &#123; for(int jp = 0;jp &lt; 4;jp++) &#123; if(ic == jc) &#123; if(jp == ip) &#123; e[ic][ip][jc][jp] = 0; &#125;else&#123; e[ic][ip][jc][jp] = c[ic].ft * d(c[ic].x[ip],c[ic].y[ip],c[jc].x[jp],c[jc].y[jp]); &#125; &#125;else&#123; e[ic][ip][jc][jp] = fp * d(c[ic].x[ip],c[ic].y[ip],c[jc].x[jp],c[jc].y[jp]); &#125; //cout &lt;&lt; e[ic][ip][jc][jp] &lt;&lt; endl; &#125; &#125; &#125; &#125; //floyd for(int kc = 0;kc &lt; ncity;kc++) &#123; for(int kp = 0;kp &lt; 4;kp++) &#123; for(int ic = 0;ic &lt; ncity;ic++) &#123; for(int ip = 0;ip &lt; 4;ip++) &#123; for(int jc = 0;jc &lt; ncity;jc++) &#123; for(int jp = 0;jp &lt; 4;jp++) &#123; e[ic][ip][jc][jp] = mymin(e[ic][ip][jc][jp],e[ic][ip][kc][kp] + e[kc][kp][jc][jp]); &#125; &#125; &#125; &#125; &#125; &#125; for(int oi = 0;oi &lt; 4;oi++) &#123; for(int ei = 0;ei &lt; 4;ei++) &#123; ans = mymin(ans,e[op-1][oi][ed-1][ei]); &#125; &#125; printf(\"%.1lf\\n\",ans); &#125; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://orangecheers.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"[p1004]方格取数","slug":"p1004-方格取数","date":"2018-01-10T08:10:55.000Z","updated":"2020-03-06T15:41:48.000Z","comments":true,"path":"2018/01/10/p1004-方格取数/","link":"","permalink":"https://orangecheers.top/2018/01/10/p1004-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/","excerpt":"#P1004 方格取数 题目描述 设有N*N*的方格图(N&lt;=9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字0。如下图所示（见样例）：","text":"#P1004 方格取数 题目描述 设有N*N*的方格图(N&lt;=9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字0。如下图所示（见样例）： A 0 0 0 0 0 0 0 0 0 0 13 0 0 6 0 0 0 0 0 0 7 0 0 0 0 0 0 14 0 0 0 0 0 21 0 0 0 4 0 0 0 0 15 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . B 某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。 此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。 ##输入输出格式 ###输入格式： 输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。 ###输出格式： 只需输出一个整数，表示2条路径上取得的最大的和。 ##输入输出样例 ###输入样例#1： 8 2 3 13 2 6 6 3 5 7 4 4 14 5 2 21 5 6 4 6 3 15 7 2 14 0 0 0 ###输出样例#1： 67 ##说明 NOIP 2000 提高组第四题 #分析 根据数据范围，显然不能采用搜索。 如果直接按照题目编写dp，显然具有后效性。在dp中无法记录走过的路径，更不可能把“走过的路径上的数变为0”，所以对于这样的问题，一般是采用多维dp，同时将路径选出。 为了方便，可以想象成有两个人，同时从起点出发，走到终点。 用dp[i][j][k][l]表示两人分别走到了(i,j)和(k,l)这两个点。 先不考虑走过的数变为0的情况，则dp[i][j][k][l]受到这四个状态的控制： dp[i-1][j][k-1][l] dp[i-1][j][k][l-1] dp[i][j-1][k-1][l] dp[i][j-1][k][l-1] 因为要取最大的数，可以得到状态转移方程如下 dp[i][j][k][l] = max{dp[i-1][j][k-1][l],dp[i-1][j][k][l-1],dp[i][j-1][k-1][l],dp[i][j-1][k][l-1]} + a[i][j] + a[k][l]; 下面可以考虑走过的数变为0这个要求了。 题目告诉我们，对于每次决策，必须且只有“向下走1格”和“向右走1格”这两种可能。 所以，无论在什么时候，两个人走到的点距离起点的曼哈顿距离都是一样的，即i+j=k+l 并且，对于一个点(i,j)，从原点出发，无论怎么走，到这个点所经过的距离均为i+j 所以可以得知，当两个人选的路程有公共点时，两个人一定同时到达这个公共点。 所以只需在进行dp的时候，判断i,j是否等于k,l,如果等于，则在转移的时候只需加一遍这个格上的数即可。 #####即 dp[i][j][k][l] = max{dp[i-1][j][k-1][l],dp[i-1][j][k][l-1],dp[i][j-1][k-1][l],dp[i][j-1][k][l-1]} + a[i][j]; 则程序不难写出 #include &lt;iostream> using namespace std; int map[15][15]; int dp[15][15][15][15]; int m; int main() &#123; cin >> m; int x,y,n; do&#123; cin >> x >> y >> n; map[x][y] = n; &#125;while(x != 0 || y != 0 || n != 0); for(int i = 1;i &lt;= m;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; for(int k = 1;k &lt;= m;k++) &#123; for(int l = 1;l &lt;= m;l++) &#123; int ma1 = max(dp[i-1][j][k-1][l],dp[i-1][j][k][l-1]); int ma2 = max(dp[i][j-1][k-1][l],dp[i][j-1][k][l-1]); dp[i][j][k][l] = max(ma1,ma2)+map[i][j]+map[k][l]; if(i == k &amp;&amp; j == l) &#123; dp[i][j][k][l] -= map[i][j]; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[m][m][m][m]; &#125; 复杂度达到O(n^4) 尽管对于这个题目而言，这么高的复杂度也能AC，但是仍有简单有效的优化方法。 首先考虑复杂度这么高的原因 #####状态参数太多 对于所有状态，我们需要四个参数才能区分他们，这是很不必要的。 前面提到过i+j=k+l这个关系。 变形一下，可得到l=i+j-k。 ###！！！ 也就是说，l这个参数可以通过前面三个参数推出来 那我还存他干什么 用dp[i][j][k]表示两人分别走到了(i,j)和(k,i+j-k)这两个点。 则状态转移方程为 dp[i][j][k] = max{dp[i-1][j][k-1],dp[i-1][j][k],dp[i][j-1][k-1],dp[i][j-1][k]} + a[i][j] + a[k][i+j-k];(i,j != k,l) dp[i][j][k] = max{dp[i-1][j][k-1],dp[i-1][j][k],dp[i][j-1][k-1],dp[i][j-1][k]} + a[i][j];(i,j == k,l) 优化后的程序如下 #include &lt;iostream> using namespace std; int map[15][15]; int dp[15][15][15]; int m; int main() &#123; cin >> m; int x,y,n; do&#123; cin >> x >> y >> n; map[x][y] = n; &#125;while(x != 0 || y != 0 || n != 0); for(int i = 1;i &lt;= m;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; for(int k = 1;k &lt;= m;k++) &#123; int l = i + j - k; int ma1 = max(dp[i-1][j][k-1],dp[i-1][j][k]); int ma2 = max(dp[i][j-1][k-1],dp[i][j-1][k]); dp[i][j][k] = max(ma1,ma2)+map[i][j]+map[k][l]; if(i == k &amp;&amp; j == l) &#123; dp[i][j][k] -= map[i][j]; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[m][m][m]; &#125; 复杂度O(n^3)","categories":[{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://orangecheers.top/tags/dp/"}]},{"title":"很多人活了一辈子","slug":"很多人活了一辈子","date":"2017-12-13T06:39:56.000Z","updated":"2020-03-06T15:37:24.000Z","comments":true,"path":"2017/12/13/很多人活了一辈子/","link":"","permalink":"https://orangecheers.top/2017/12/13/%E5%BE%88%E5%A4%9A%E4%BA%BA%E6%B4%BB%E4%BA%86%E4%B8%80%E8%BE%88%E5%AD%90/","excerpt":"","text":"都不知道六楼机房的门能反锁","categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]}],"categories":[{"name":"其他","slug":"其他","permalink":"https://orangecheers.top/categories/%E5%85%B6%E4%BB%96/"},{"name":"题解","slug":"题解","permalink":"https://orangecheers.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"私号公用","slug":"私号公用","permalink":"https://orangecheers.top/categories/%E7%A7%81%E5%8F%B7%E5%85%AC%E7%94%A8/"},{"name":"游记","slug":"游记","permalink":"https://orangecheers.top/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://orangecheers.top/categories/%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://orangecheers.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"练习赛记录","slug":"练习赛记录","permalink":"https://orangecheers.top/categories/%E7%BB%83%E4%B9%A0%E8%B5%9B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://orangecheers.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"计算机网络 组网","slug":"计算机网络-组网","permalink":"https://orangecheers.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BB%84%E7%BD%91/"},{"name":"机器学习","slug":"机器学习","permalink":"https://orangecheers.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://orangecheers.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数理","slug":"数理","permalink":"https://orangecheers.top/tags/%E6%95%B0%E7%90%86/"},{"name":"图论","slug":"图论","permalink":"https://orangecheers.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://orangecheers.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://orangecheers.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"KMP","slug":"KMP","permalink":"https://orangecheers.top/tags/KMP/"},{"name":"SA后缀数组","slug":"SA后缀数组","permalink":"https://orangecheers.top/tags/SA%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"前缀数组","slug":"前缀数组","permalink":"https://orangecheers.top/tags/%E5%89%8D%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"https://orangecheers.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://orangecheers.top/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://orangecheers.top/tags/2-SAT/"},{"name":"算法总结","slug":"算法总结","permalink":"https://orangecheers.top/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"网络流","slug":"网络流","permalink":"https://orangecheers.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"基础算法","slug":"基础算法","permalink":"https://orangecheers.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"二分","permalink":"https://orangecheers.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://orangecheers.top/tags/dp/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://orangecheers.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"询问差分","slug":"询问差分","permalink":"https://orangecheers.top/tags/%E8%AF%A2%E9%97%AE%E5%B7%AE%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://orangecheers.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"贪心","slug":"贪心","permalink":"https://orangecheers.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"分块","slug":"分块","permalink":"https://orangecheers.top/tags/%E5%88%86%E5%9D%97/"},{"name":"分治","slug":"分治","permalink":"https://orangecheers.top/tags/%E5%88%86%E6%B2%BB/"},{"name":"分层图","slug":"分层图","permalink":"https://orangecheers.top/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"},{"name":"巧妙的解法","slug":"巧妙的解法","permalink":"https://orangecheers.top/tags/%E5%B7%A7%E5%A6%99%E7%9A%84%E8%A7%A3%E6%B3%95/"}]}